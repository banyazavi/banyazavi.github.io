var store = [{
        "title": "root 도메인을 www로 리다이렉트 시키기",
        "excerpt":"   가정에서 운영하는 서버에 도메인을 연결해 운영한다면, 보통 이 문제에 마주치게 됩니다.      이 글은 root 도메인에 A레코드를 지정하지 못하는 상황에서, root 도메인을 www로 리다이렉트하는 서비스를 이용하여 www 서브도메인으로 root 도메인까지 호스팅하는 방법에 대한 이야기에요.   도메인 관리 업체에서 지원하지 않는 등의 이유로 root 도메인에 A 레코드를 활용할 수 없지만, root 도메인에 대한 연결을 하고 싶을 때 사용하면 됩니다. 또는 같은 상황에서 티스토리나 깃허브 블로그에 root 도메인을 연결할 때에도 쓸 수 있어요.     root 도메인이 뭔데?   root 도메인이란 서브도메인이 없는 도메인을 의미합니다. Naked 도메인이나 Bare 도메인이라고 부르기도 해요. 그러니까 이 블로그를 예로 들면,      blog.banyazavi.com    여기서 .com을 TLDTop Level Domain라고 하고, banyazavi 부분이 2nd-level domain입니다. 그리고 blog. 부분이 sub-level domain. 즉, 서브도메인이 되는 거죠. 그러니까 서브도메인이 없다? 아무 수식어도 붙지 않은 banyazavi.com을 의미합니다.   요즘같은 시대에 root 도메인이 어떤 위상을 가지냐 하면, 사이트 자체를 의미하는 정도의 중요한 위치에 있습니다. 사실 대부분의 사이트는 www로 시작하는 서브도메인이 공식적인 주소이지만, 근래에 와서는 이를 생략하고 표현하는 경우도 많고, 심지어는 www. 도메인이나 root 도메인이나 같은 것이라고 생각하는 경우도 많습니다. 그러니까 www.는 연결되어 있는데 root 도메인이 연결되지 않는다? 그럼 이용자들에게 “사이트가 연결이 안되던데요 ㅠㅠ” 하는 피드백을 받게 되는 거죠.   그러면 “까짓거 뭐 root 도메인도 연결시키면 되네!” 싶지만,   도메인을 연결합니다. 연결하겠습니다. 안 되잖아?   문제는 일부 도메인 관리업체의 네임서비스가 root 도메인에 대한 CNAME 레코드를 지원하지 않는다는 겁니다. root 도메인에 한정해서는 오직 A 레코드만 사용할 수 있는데, 이는 root 도메인을 항상 고정 IP로만 연결되야 한다는 뜻입니다. 그런데 보통의 경우 고작 홈 서버 하나 운영하자고 그 비싼 고정 IP를 신청하기는 힘들 거에요. 그럴 거면 차라리 웹 호스팅을 받지…     제가 사용하는 호스팅케이알의 네임서버 관리 화면입니다. 당연하다는 듯이 root 도메인의 CNAME을 사용을 고려하지 않습니다.   역시 싼 맛에 어설픈 도메인 회사에서 샀다가 이렇게 피 보는구나 싶지만… 근데 이게 원칙입니다! RFC 1912을 보면 이렇게 정해져 있거든요.      2.4 CNAME records  　　A CNAME record is not allowed to coexist with any other data. In  　　other words, if suzy.podunk.xx is an alias for sue.podunk.xx, you  　　can’t also have an MX record for suzy.podunk.edu, or an A record, or  　　even a TXT record. Especially do not try to combine CNAMEs and NS  　　records like this!:  … 후략    “CNAME 레코드는 다른 데이터와 공존할 수 없습니다.” 무슨 말이냐면, 특정 도메인이 CNAME 레코드로 기술될 때에는 같은 도메인 (=서브도메인이 같은 경우) 에 CNAME 레코드만 있어야 한다는 이야기에요. 문제는 root 도메인의 경우 도메인 존의 표기를 위해 SOAStart Of Authority 레코드와 NSName Server 레코드가 필수로 들어간다는 것이죠. (물론 보통의 네임서비스 화면에는 잘 표현되지 않습니다. AWS같은 경우가 아니라면요.)   아무튼 이건 문제가 좀 있네요. 유동 IP는 root 도메인을 쓸 수가 없다니… 그래서 이를 극복할 수 있는 서비스가 찾아봤습니다.   아주 간단한 방법, wwwizer의 Nake Domain Redirect 서비스를 이용하기   wwwizer.com이라는 SSL 프록시 서비스 업체가 있습니다. 이 업체가 제공하는 root 도메인 리다이렉트 서비스는 적용이 매우 간단합니다. 해당 업체의 사이트에서는 그 방법을 이렇게 소개하고 있습니다.      How can I use this service?  Point your “naked domain” (example.com not www.example.com!) to IP address 174.129.25.170     어떻게 이 서비스를 사용할 수 있나요?  당신의 “naked(root) 도메인” (www.example.com 아니고 example.com)을 IP 174.129.25.170에 연결하세요.    즉, 위의 저 IP를 네임서버 root 도메인의 A 레코드에 넣으면 알아서 www.로 리다이렉트 시켜줍니다. 참 쉽죠?   그런데 이 방법, 조금 찜찜합니다.      살짝 느립니다. 뭐, 당연히 서버는 해외에 있을 것이고, 무료에 등록도 안하고 이 업체의 IP 지정하기만 하면 모든 도메인에 www. 붙여서 돌려준다는 서비스인데 이게 마냥 빠를 수는 없겠죠.   신뢰할 만한 업체일까요? 외관이 모든 것을 결정하지는 않지만, 사이트를 들어가보면 너무나 단순해서 불안할 정도네요.   이런 서비스의 공통적인 문제점이겠지만 저희는 이 업체에 A 레코드의 처리를 위탁하게 되므로, 업체가 나쁜 마음을 먹거나 해킹당했을 경우 사이트 위조같은 문제가 발생할 수 있겠네요. 일단 느리기도 하구요.   그래서 조금 더 예쁜 신뢰가는 서비스를 찾아봤습니다.   등록하여 사용하는 방법, NakedSSL 서비스 이용하기   NakedSSL은 이름만 봐도 알 수 있듯이, 원래는 Naked (root) 도메인에 대하여 SSL을 적용시켜 주는 사이트입니다. 리다이렉트 타겟이 되는 www. 사이트에 SSL 인증이 되어야 한다는 전제가 필요하긴 하지만, 때문에 아까와 같은 방식처럼 무분별하게 사용된다는 느낌은 없네요. 1개 사이트에 대한 리다이렉트까지 무료이고, 그 이상의 경우 요금이 발생하니, 다수의 도메인을 관리할 경우 다수의 G메일 주소를 생성할 것을 결제를 고려해 봅시다.     신뢰의 상징 예쁜 홈 페이지   어찌저찌 회원가입을 하고 나면 아래와 같은 대시보드가 나옵니다.     사막과 같이 공허하다니 어머 오빠 너무 낭만적이야   여기에 “Add Domain” 버튼을 눌러 우리 사이트를 추가해봅시다.      사이트 주소를 이렇게 넣고 “Next”를 누르면,      도메인을 리다이렉트 해 줄 서버를 선택하는 화면입니다. 이 서버는 결국 도메인 이름을 중개해주는 역할이므로, 사용자와 가까이 있는 것이 좋죠. 실험해 본 결과 한국에서는 미국 서버가 더 빠르네요.      이어서 상세 설정 화면이 나오는데, 사이트 캐시와 STSStrict Transport Security에 관한 설정입니다. 잘 설정하면 좀 더 안정적인 사이트 운영이 가능하겠으나, 무슨 말인지 잘 모르므로 건드리지 말고 넘어갑시다. (아마도 HSTSHTTP Strict Transport Security 옵션 (HTTPS 연결 강제) 을 의미하는 거겠죠.) 화면의 영문 설명도 “무슨 말인지 이해 못했다면 걱정하지 마시고 기본 값으로 진행하세요.” 라고 되어있네요.      이제 DNS 네임서버에 어떻게 설정하면 되는지를 안내하는데, 이것은 아래에 나온 IP를 root 도메인의 A 레코드에 적으라는 의미입니다. 그러니까 제 도메인 관리 페이지에서는 아래와 같이 설정이 되겠죠.      네임서버 관리 화면에 아까 본 IP(숫자)를 이렇게 넣고, 리다이렉트 받을 www. 서브도메인에 홈 서버의 DDNS(알파벳 주소)를 적어 넣습니다.   도메인 관리업체에 정보를 입력하는 사이에 NakedSSL도 준비가 완료되었을 것이므로, 다시 사이트로 돌아가서 “DNS updated” 버튼을 눌러봅시다. 그러면,      쨘! 이렇게 등록이 준비되고 있는 화면이 나옵니다! 이제 기다리면 스케줄에 따라 모든 정보가 업데이트 및 생성되며 완료되는데, 기다리기 답답하다면 위의 “Check DNS now” 버튼을 눌러 진행을 독촉하도록 합시다. 그래도 SSL 인증에 시간이 꽤 걸리므로, 느긋하게 기다리는 편이 좋습니다.      이렇게 나오면 끝입니다. 이제 root 도메인으로 접속하여 정상적으로 리다이렉트 되는지 확인해 봅시다.     그리고 남은 이야기   글을 작성하는 지금, 제 도메인은 위와 같은 과정으로 root 도메인이 www.에 리다이렉트되어 있지만, 실제 접속해보면 바로 blog.로 주소가 바뀌어 연결되는 것을 볼 수 있습니다. 이것은 홈 서버의 서비스 노출을 최대한 막아보기 위해, 서버의 Nginx가 특수한 경우를 제외한 모든 www. 요청을 blog.로 보내고 있기 때문인데요. Nginx를 활용한 리버스 프록시 설정에 관한 이야기는 다음에 다루도록 하겠습니다.  ","categories": [],
        "tags": ["CNAME","DNS","도메인"],
        "url": "http://0.0.0.0:4000/2019-09-08/root-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%84-www%EB%A1%9C-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%8A%B8-%EC%8B%9C%ED%82%A4%EA%B8%B0",
        "teaser":null},{
        "title": "리눅스에서 부트 이미지 플래싱하기",
        "excerpt":"   SD Memory Card Formatter와 Win32 Disk Imager와 같은 복잡한 툴 없이도 SBC에 OS 이미지를 설치할 수 있습니다.      설치 방법이 더 복잡해 보이는 것은 기분 탓입니다.     왜 이런 방법을 찾게 되었냐면   제가 가지고 있는 ODROID XU4 때문은 eMMC를 디스크로 사용하거든요…   오드로이드는 다른 SBCSingle Board Computer와는 다르게 eMMCembedded Multi Media Card 슬롯을 제공하는데요, 이 규격은 보통 스마트폰에 주로 사용되는 것으로 SBC에 자주 쓰이는 SDSecure Digital 카드보다 읽고 쓰는 속도가 빠릅니다. 그래서 XU4를 구매할 때, eMMC를 덥썩 샀고, 그 결과…   문제는 이게 주로 “스마트폰에 납땜해서 들어가는 모듈”이고, 그래서 일반적인 리더기가 없다는 점입니다. 오드로이드용 eMMC 전용 리더기가 있긴 한데 품질이 매우 조악해서 벌써 고장났어요. 다시 구하자니 이게 또 흔하게 파는 물건이 아니라 쉽게 구할 수도 없구요.   그래서 결국 SD카드에 리눅스가 설치된 eMMC 슬롯이 달려있는 XU4 그 자체를 리더기로 해서 설치하는 방법을 찾게 되었습니다. 저는 이 방법을 주로 eMMC에 OS 플래싱할 때만 사용했는데, 이리 저리 알아보니 해놀로지 부트로더 설치할 경우 등, 많은 상황에 응용이 가능한 것 같습니다.   이 글은 XU4에 설치하는 것을 가정해서 작성했는데요, 달라지는 부분을 파악할 수 있다면 다른 장치에도 적용할 수 있을 거에요.   준비물      리눅스가 설치된 PC   부트 이미지를 설치할 메모리와 이를 PC에 인식할 수 있는 장비   부트 이미지 파일 (OS 설치파일 압축을 풀었는데 .img이다? 바로 그겁니다.)   플래싱할 장치 찾기   fdisk 명령을 통해 플래싱할 장치의 경로를 찾습니다. 너무 많은 장비가 꽂혀있을 경우 찾기가 매우 난감할 수 있는데요, 용량 등의 정보를 잘 확인하여 실수하지 않도록 합니다.   명령   $ sudo fdisk -l   결과   ... Disk /dev/mmcblk0: 14.7 GiB, 15758000128 bytes, 30777344 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x3cedfd53  Device         Boot  Start      End  Sectors  Size Id Type /dev/mmcblk0p1        2048   264191   262144  128M  c W95 FAT32 (LBA) /dev/mmcblk0p2      264192 30775296 30511105 14.6G 83 Linux ...   제가 이미지를 플래싱할 장치는 16GB의 eMMC 장치입니다. /dev/mmcblk0p1와 /dev/mmcblk0p2에 파티션이 이미 할당되어 있는데요, 이전에 리눅스를 설치했던 흔적입니다. 어차피 밀어버릴 것이므로 신경쓸 필요는 없습니다. 아, 자료가 지워지므로 백업을 했는지는 확인해야 겠네요.   아무튼 여기서 우리는 /dev/mmcblk0라는 장치 경로를 확인했습니다. 기억해 둡시다.   플래싱 명령 수행   dd 명령어를 통해 이미지를 플래싱합니다.   명령   $ sudo dd bs=4M if=ubuntu-18.04-odroid-xu4.img of=/dev/mmcblk0 &amp;&amp; sync   dd는 파일 변환/복사 명령어입니다. 사용된 옵션 의미는 이렇습니다.      bs=4M (Block Size: 한번에 읽고 쓸 용량 단위, 여기선 4M로 했는데 적당한 다른 용량을 사용해도 상관 없는 것 같네요.)   if=ubuntu-18.04-odroid-xu4.img (Stdin from File: 복사할 원본 파일)   of=/dev/mmcblk0 (Stdout to File: 복사할 목적 파일)   sync (메모리와 디스크를 동기화. dd 이후에도 플래싱이 덜 끝난 상황을 방지한다고 해요.)   명령 (.xz 압축 파일에서 바로 플래싱)   $ sudo xzcat ubuntu-18.04-odroid-xu4.img.xz | dd bs=4M of=/dev/mmcblk0 &amp;&amp; sync   OS 설치 이미지는 .xz 형식으로 압축되어 있는 경우가 많은데, 이 경우에는 압축을 풀며 바로 플래싱을 진행할 수도 있습니다.   결과   665+1 records in 665+1 records out 2791309312 bytes (2.8 GB, 2.6 GiB) copied, 229.743 s, 12.1 MB/s   위와 같이 복사가 진행되었다는 결과가 출력됩니다.     그리고 남은 이야기   이러한 대삽질을 겪고 난 교훈으로, 현재 사용하는 ODROID H2는 eMMC를 구입하지 않았습니다. 하지만 XU4가 테스트 머신이 되어버려서 dd를 더 자주 쓰게 됨…   물론, H2는 NVMeNon-Volatile Memory express라는 훨씬 빠른 저장장치가 지원되고 있기 때문이기도 합니다. 또한 x86 머신에서는 eMMC가 잘 사용되는 장치가 아니어서 드라이버 지원이 미비하기도 하구요.  ","categories": [],
        "tags": ["eMMC","SBC","플래싱"],
        "url": "http://0.0.0.0:4000/2019-09-15/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%EB%B6%80%ED%8A%B8-%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%94%8C%EB%9E%98%EC%8B%B1%ED%95%98%EA%B8%B0",
        "teaser":null},{
        "title": "ODROID XU4 - OMV 설치 후 파티션 용량 늘리기",
        "excerpt":"   16GB 이상의 SD카드나 eMMC를 샀는데, OMV 설치 후 8GB밖에 쓸 수 없다면 본전 생각이 나겠죠.        나는 16GB eMMC를 샀는데 왜      ODROID XU4에 OMV4를 설치 후 파일 시스템 항목에 들어가면, 위와 같이 7GB 정도의 용량만 잡혀 있는 것을 볼 수 있습니다. 처음에는 SWAP 파티션 (가상 메모리 비슷한 것) 이 아닐까 하는 생각도 해 보았지만, eMMC 용량의 절반을 잡는 것은 너무하잖아요.   그래서 찾아보니, 이미지 자체가 8GB를 기준으로 만들어져 있다고 합니다.   왜 용량이 이것밖에 안 되지?   임베디드 장치에 OS를 설치, 즉 플래싱하는 방법은 마치 윈도우 복원과 비슷합니다. OS 이미지 배포 작업자가 어떤 신묘한 방법으로 해당 임베디드 장치에 대하여 설치작업을 진행한 후, 그 상태의 설치 상황을 디스크 째로 이미지로 만드는 방식인데요. 임베디드 장비는 스펙이 모두 동일하기 때문에 이러한 방법이 가능해요. 애당초 바이오스와 같은 시스템 초기 환경을 구성하는 방법이 없는 임베디드 장비는 OS를 배포할 수단이 많지가 않습니다.   그렇기 때문에 대부분의 임베디드 장비는 설치 기본 ID와 비밀번호 등이 고정되어 있고, 이미지 배포 시 이를 같이 알려주는 방식으로 되어 있습니다. 예를 들면 라즈베리 파이의 리눅스 이미지는 ID = “pi”, 비밀번호 = “raspberry”죠.   따라서 .iso CD 이미지로 설치하는 데스크탑 시스템에서는 이 방법이 의미가 없습니다. 대신에 OMV의 경우 전문가 설치 메뉴를 통하지 않으면, 설치 관리자가 SWAP 파티션 등을 고려하여 임의로 파티션을 나누므로 이것이 마음에 들지 않을 수 있습니다. 이 때는 전문가 설치 메뉴를 통해 설치하여 조정하거나, Debian을 직접 설치한 후 설치 스크립트를 통해 OMV를 설치하면 됩니다.   준비물      OMV가 설치되어 있는 ODROID XU4. .img 형식의 플래싱 이미지로 설치하는 다른 임베디드 장치도 가능합니다.   일단 OMV 웹 패널에 접속하여 서비스 &gt; SSH 메뉴에서 ‘루트 로그인을 허용합니다’를 체크합니다. 또는 장비에 모니터와 키보드를 꽂아 직접 할 수도 있어요.   OMV 초기 설정은 ID = ‘root’, 비밀번호 = ‘openmediavault’입니다. SSH에 최초 접속 시 바로 비밀번호 변경을 진행하게 됩니다.   대상 디스크 찾기   fdisk 명령을 통해 OMV가 설치된 디스크를 찾습니다. dd로 OS 이미지 플래싱하셨던 분이면 어떤 내용인지 아실 거에요.   명령   root@odroidxu4:~# fdisk -l   결과   ... Disk /dev/mmcblk0: 14.7 GiB, 15758000128 bytes, 30777344 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x01bb5fb4  Device         Boot    Start      End  Sectors  Size Id Type /dev/mmcblk0p1          8192   139263   131072   64M 83 Linux /dev/mmcblk0p2        139264 15500000 15360737  7.3G 83 Linux /dev/mmcblk0p3      15500001 30469567 14969567  7.1G 83 Linux ...   여기서 기억해야 할 내용은 OMV가 설치된 디스크의 경로가 /dev/mmcblk0이라는 것과, 파티션을 조절해야 하는 파티션이 ‘2번 파티션’, 시작 섹터 번호가 ‘139264’번이라는 점입니다.   파티션 조정 실행   fdisk는 원래 파티션을 관리하는 프로그램입니다. 아래 명령을 사용하여 파티션 조정을 실행합니다. 위에서 확인한 값에 따라 일부 내용이 변경될 수 있는 점 참고하세요.   fdisk 실행   root@odroidxu4:~# fdisk /dev/mmcblk0  Welcome to fdisk (util-linux 2.29.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command.   Command (m for help):  ...   fdisk에 잘 접속하였다면 다음 화면을 볼 수 있습니다. 잘 선택되었는지 확신이 서지 않는다면 먼저 p 명령을 입력하여 fdisk -l에서 확인한 디스크의 내용과 동일하게 출력되는지 확인합시다.   3번, 2번 파티션 삭제   ... Command (m for help): d Partition number (1-3, default 3): 3  Partition 3 has been deleted.  Command (m for help): d Partition number (1,2, default 2): 2  Partition 2 has been deleted.  Command (m for help): ...   3번 파티션과 2번 파티션을 삭제합니다.   새 파티션 생성   ... Command (m for help): n Partition type     p   primary (1 primary, 0 extended, 3 free)     e   extended (container for logical partitions) Select (default p): p Partition number (2-4, default 2): 2 First sector (2048-30777343, default 2048): 139264 Last sector, +sectors or +size{K,M,G,T,P} (139264-30777343, default 30777343): 30777343  Created a new partition 2 of type 'Linux' and of size 14.6 GiB. Partition #2 contains a btrfs signature.  Do you want to remove the signature? [Y]es/[N]o: N  Command (m for help): ,,,   Primary 타입의 새 파티션 2번을 만듭니다.   첫번째 섹터는 아까 확인한 숫자 ‘139264’를 입력합니다. 기본값인 2048을 입력하면 ‘1번 파티션’ (부트 파티션) 앞쪽의 매우 작은 영역을 선택하는 것이 됩니다. 조심하세요!   마지막 섹터는 ‘default’ 값을 사용합니다. 즉, 가장 큰 용량을 지정한다는 뜻이에요.   그러면 새 파티션을 만들었다는 말과 함께 시그니처를 삭제하겠냐고 물어보는데, 파티션 포맷이 변할 것은 아니므로 ‘N’을 선택하면 됩니다.   파티션 설정 정보 기록   ... Command (m for help): w  The partition table has been altered. Calling ioctl() to re-read partition table. Re-reading the partition table failed.: Device or resource busy  The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8).  root@odroidxu4:~# ...   그리고 이제 ‘W’를 눌러 파티션을 기록해주면, 뭔가를 하라는 메시지와 함께 fdisk가 종료됩니다. 그러니까, 더 할게 남았다는 거죠.   btrfs 파티션 조정 명령 실행   ... root@odroidxu4:~# btrfs filesystem resize max / Resize '/' of 'max' root@odroidxu4:~# ...   명령 설명하기 전에 잠깐. fdisk 명령의 마지막에 partprobe 명령이나 kpartx 명령을 사용하라고 적혀있는데, 실제로 실행해보면 partprobe 명령은 오류가 나고, kpartx 명령은 없다고 나오네요. 그래서 재부팅 후 적용해보기로 했습니다.   오드로이드 XU용 OMV 이미지에 사용된 btrfs 형식의 파티션은 fdisk 이후에 다음과 같은 절차가 필요한 것 같습니다. 위 명령은 루트 경로 (/) 에 대해 최대 용량 (max) 으로 조절하라는 의미입니다.   동기화, 그리고 재부팅   root@odroidxu4:~# sync root@odroidxu4:~# reboot   왠지 이런 작업 후에는 꼭 해야 할 것 같은 sync를 한번 하구요, reboot 명령으로 재부팅을 합니다. 그리고 다시 OMV 웹 패널의 파일 시스템 항목을 보면…   쨘!      잘 적용된 것을 볼 수 있습니다.     그리고 남은 이야기, 요약   임베디드 장비이므로 초기 파티션 설정이 똑같다는 점과, fdisk의 default 설정이 잘 되어 있다는 점을 고려하면, 위의 과정을 다음과 같은 명령어들로만 요약할 수 있습니다.   물론, 어떤 의미인지는 알고 하시는 게 좋겠죠.   root@odroidxu4:~# fdisk /dev/mmcblk0  Command (m for help): d Partition number (1-3, default 3): [enter]  Command (m for help): d Partition number (1,2, default 2): [enter]  Command (m for help): n Select (default p): p Partition number (2-4, default 2): [enter] First sector (2048-30777343, default 2048): 139264 Last sector, +sectors or +size{K,M,G,T,P} (139264-30777343, default 30777343): [enter] Do you want to remove the signature? [Y]es/[N]o: N  Command (m for help): w  root@odroidxu4:~# btrfs filesystem resize max /  root@odroidxu4:~# sync root@odroidxu4:~# reboot   2019. 12. 9 추가   openmediavault의 이미지 다운로드 페이지에 가 보니, 12월 9일자로 이런 내용과 함께 SBC용 이미지들이 거의 다 지워져 있더라구요.      The pre-install images have been deprecated in favor of using this guide - https://forum.openmediavault.org/index.php/Thread/28789-Installing-OMV5-on-Raspberry-PI-s-Armbian-Supported-SBC-s/     Source: readme.txt, updated 2019-12-09    대략, ARM 아키텍처의 SBC는 앞으로 ARM용 Debian (Raspbian이나 Armbian) 을 설치 후, 스크립트를 통하여 OMV를 설치하라는 내용이네요.   따라서 이 글도 거의 무의미해지게 되었네요. Armbian을 통해서 OMV 설치하는 방법을 준비해야 겠어요.  ","categories": [],
        "tags": ["ODROID XU4","openmediavault"],
        "url": "http://0.0.0.0:4000/2019-09-28/ODROID-XU4-OMV-%EC%84%A4%EC%B9%98-%ED%9B%84-%ED%8C%8C%ED%8B%B0%EC%85%98-%EC%9A%A9%EB%9F%89-%EB%8A%98%EB%A6%AC%EA%B8%B0",
        "teaser":null},{
        "title": "ODROID H2용 ESXi 6.7 설치 이미지 만들기",
        "excerpt":"   오드로이드 H2에 여러 가지 OS를 설치하고 싶으면 따라해 봅시다.        ESXi란?   VMware에서 제품 개요를 가져왔어요.      VMware ESXi: 맞춤형 베어메탈 하이퍼바이저  물리적 서버에 바로 설치되는 강력한 베어메탈 하이퍼바이저에 대해 알아보십시오. VMware ESXi는 기반 리소스에 대한 직접 액세스와 제어가 가능하므로 하드웨어를 효과적으로 파티셔닝하여 애플리케이션을 통합하고 비용을 절감할 수 있습니다. 또한 업계 최고의 효율적인 아키텍처로서 안정성과 성능, 지원에 대한 표준이 되고 있습니다.  - VMWare ESXi 제품 개요    VMWare ESXi는 VMWare에서 만든 베어메탈 하이퍼바이저Bare Metal Hypervisor입니다. 그러니까 호스트 하이퍼바이저와는 달리 하드웨어 위에 가상화 환경이 바로 설치되는… 어렵네요.   간단하게 설명하자면, 컴퓨터를 켜면 바로 VMWare (가상 머신 관리 도구) 가 실행되는 시스템을 의미합니다. 호스트 운영체제 (윈도우나 우분투 리눅스 같은) 없이 바로 설치되기 때문에, 호스트 운영체제 구동에 필요한 자원 낭비를 하지 않아 최적의 성능을 뽑아낼 수 있어요.   그렇다고 전문적인 서버도 아닌 오드로이드 H2에 대단한 성능을 바랄 수는 없겠죠.   ODROID H2에 ESXi 설치하기   베어메탈 하이퍼바이저가 여러 종류가 있겠지만, 홈 서버 레벨에서 ESXi가 주로 추천되는 이유는 공짜이기 때문일 겁니다. VMWare에 회원가입을 하면 ESXi 설치파일과 라이센스를 무료로 받을 수 있거든요.   그렇다고 무턱대고 파일을 받아 실제로 설치를 진행하다 보면 잘 안 되는데, 그건 오드로이드 H2의 NVMe와 NIC 드라이버가 기본 포함되어 있지 않기 때문입니다.   다행히도 오드로이드 포럼에 설치법이 공유되어 있어, 이 글에서는 그 설치법을 번역하여 소개해 보도록 하겠습니다.   # Complete guide for running ESXi 6.7.0 update 03 on Odroid H2 with NVMe SSD   준비물      ODROID H2   NVMe SSD (NVMe를 지원하도록 드라이버를 설치하는 것이므로 꼭 장착되어 있을 필요는 없습니다.)   Windows 10이 설치된 컴퓨터   2개의 USB 3.0 메모리 (하나는 설치 이미지가 담긴 USB, 나머지 하나는 ESXi가 설치될 USB) - USB에 ESXi를 설치할 계획이 아니면 1개만 있어도 됩니다.   그리고 다음 파일들도 준비합니다.      VMWare에서 제공하는 ESXi 6.7.0 update-from-esxi6.7-6.7_update03. 로그인 후, 여기에서 검색하여 받을 수 있습니다. https://my.vmware.com/group/vmware/patch#search   Realtek 8168/8111/8411/8118 기반 NIC 드라이버 https://vibsdepot.v-front.de/wiki/index.php/Net55-r8168    NVMe 드라이버 https://hostupdate.vmware.com/software/ … 169922.vib 이 링크는 누르면 이상한 페이지가 나올텐데, 링크를 우클릭 -&gt; 다른 이름으로 링크 저장을 클릭하여 다운받도록 합니다.   Rufus (.iso 파일을 USB에 설치하기 위한 프로그램) https://rufus.ie/   그리고 이 파일들을 한 폴더에 몰아넣고, CMD 환경에서 접근하기 좋은 위치에 둡니다. C:\\ 또는 D:\\ 같은 곳이 찾기 쉬울 거에요.   드라이버 통합된 설치 이미지 만들기   우선 윈도우 명령 프롬프트를 ‘관리자 권한으로 실행’합니다. 그리고 cd 명령으로 다운받아둔 폴더가 있는 곳으로 이동합시다. 저는 C:\\ESXi에 파일을 모아놨어요.   PowerShell 실행   c:\\&gt;cd ESXi  c:\\ESXi&gt;powershell Windows PowerShell Copyright (C) Microsoft Corporation. All rights reserved.  새로운 크로스 플랫폼 PowerShell 사용 https://aka.ms/pscore6  PS C:\\ESXi&gt; ...   PowerShell 실행 환경으로 전환합니다. 이제 커맨드라인 앞에 ‘PS’가 붙어 나오는 것을 볼 수 있습니다. 사실 바로 PowerShell을 실행시켜 사용할 수도 있는데요, 일단 원문의 가이드를 충실히 따라가도록 합시다.   PowerShell 스크립트 실행 제한 해제   ... PS C:\\ESXi&gt; Set-ExecutionPolicy Unrestricted Set-ExecutionPolicy : Windows PowerShell에서 실행 정책을 업데이트했지만 좀 더 구체적인 범위에서 정의된 정책에 의해 설정 이 재정의되었습니다. 재정의로 인해 셸은 현재 유효 실행 정책인 RemoteSigned을(를) 유지합니다. 실행 정책 설정을 보려면 \"G et-ExecutionPolicy -List\"를 입력하십시오. 자세한 내용은 \"Get-Help Set-ExecutionPolicy\"를 참조하십시오. 위치 줄:1 문자:1 + Set-ExecutionPolicy Unrestricted + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     + CategoryInfo          : PermissionDenied: (:) [Set-ExecutionPolicy], SecurityException     + FullyQualifiedErrorId : ExecutionPolicyOverride,Microsoft.PowerShell.Commands.SetExecutionPolicyCommand PS C:\\ESXi&gt; ...   커스텀 ESXi 이미지 생성 중 스크립트 실행이 필요하므로, 실행 정책을 수정하는 과정입니다.   VMWare CLI 모듈 설치   ... PS C:\\ESXi&gt; Install-Module -Name VMware.PowerCLI  신뢰할 수 없는 리포지토리 신뢰할 수 없는 리포지토리에서 모듈을 설치하는 중입니다. 이 리포지토리를 신뢰하는 경우 Set-PSRepository cmdlet을 실행하여 InstallationPolicy 값을 변경하십시오. 'PSGallery'에서 모듈을 설치하시겠습니까? [Y] 예(Y)  [A] 모두 예(A)  [N] 아니요(N)  [L] 모두 아니요(L)  [S] 일시 중단(S)  [?] 도움말 (기본값은 \"N\"): A PS C:\\ESXi&gt; ...   PowerShell용 VMWare 도구 설치를 위해 모듈을 설치합니다. 신뢰할 수 없다고 경고가 뜨는데, 윈도우 입장에서는 신뢰할 수 없는게 맞고 우리는 필요한 것도 맞으니 (…) 그냥 진행합니다.   이미지 생성을 위한 파일 추가하기   ... PS C:\\ESXi&gt; Add-EsxSoftwareDepot .\\net55-r8168-8.045a-napi-offline_bundle.zip  Depot Url --------- zip:C:\\ESXi\\net55-r8168-8.045a-napi-offline_bundle.zip?index.xml   PS C:\\ESXi&gt; Add-EsxSoftwareDepot .\\update-from-esxi6.7-6.7_update03.zip  Depot Url --------- zip:C:\\ESXi\\update-from-esxi6.7-6.7_update03.zip?index.xml   PS C:\\ESXi&gt; Get-EsxSoftwarePackage -PackageUrl .\\VMW_bootbank_nvme_1.2.1.34-1vmw.670.0.0.8169922.vib  Name                     Version                        Vendor     Creation Date ----                     -------                        ------     ------------- nvme                     1.2.1.34-1vmw.670.0.0.8169922  VMW        2018-04-03 오...   PS C:\\ESXi&gt; ...   다운받아둔 파일과 NVMe 드라이버용 스크립트를 실행합니다. 파일명과 경로가 맞는지 다시 한번 확인하세요!   ESXi 설치 정보 구성하기   ... PS C:\\ESXi&gt; New-EsxImageProfile -cloneprofile ESXi-6.7.0-20190802001-standard -Name ODroidH2 -Vendor Custom  Name                           Vendor          Last Modified   Acceptance Level ----                           ------          -------------   ---------------- ODroidH2                       Custom          2019-08-08 ...  PartnerSupported   PS C:\\ESXi&gt; Set-EsxImageProfile -ImageProfile \"ODroidH2\" -AcceptanceLevel CommunitySupported  Name                           Vendor          Last Modified   Acceptance Level ----                           ------          -------------   ---------------- ODroidH2                       Custom          2019-09-29 ...  CommunitySupported   PS C:\\ESXi&gt; Add-EsxSoftwarePackage -ImageProfile \"ODroidH2\" -SoftwarePackage \"nvme 1.2.1.34-1vmw.670.0.0.8169922\"  Name                           Vendor          Last Modified   Acceptance Level ----                           ------          -------------   ---------------- ODroidH2                       Custom          2019-09-29 ...  CommunitySupported   PS C:\\ESXi&gt; Add-EsxSoftwarePackage -ImageProfile \"ODroidH2\" -SoftwarePackage net55-r8168  Name                           Vendor          Last Modified   Acceptance Level ----                           ------          -------------   ---------------- ODroidH2                       Custom          2019-09-29 ...  CommunitySupported   PS C:\\ESXi&gt; ...   설치된 이미지의 프로파일을 작성합니다. 요약하자면 ODroidH2라는 이미지를 생성하고, 아까 추가한 드라이버들을 추가하는 과정이에요. 프로파일을 생성할 때 사용하는 ‘Name’과 ‘Vendor’ 부분은 후에 ESXi 관리 패널의 ‘호스트 &gt; 구성’ 부분에 적히게 됩니다.   필요하다면 다른 이름과 벤더명으로 작성할 수도 있어요. 대신에 아래 내용도 그에 맞게 바꿔야 합니다.   .iso 파일 생성하기   ... PS C:\\ESXi&gt; Export-EsxImageProfile -ImageProfile \"ODroidH2\" -ExportToIso -FilePath .\\ODroidH2.iso PS C:\\ESXi&gt;   잘 실행되었으면 설치 파일들을 저장한 폴더에 ‘ODroidH2.iso’ 이름으로 파일이 생성되어 있게 됩니다.     그리고 남은 이야기   이 글을 쓴 이후에 Proxmox VE이라는 같은 다른 무료 하이퍼바이저도 설치해 봤습니다.   프록스목스 VE의 경우는 Debian 위에 올라가므로, 오드로이드 H2의 모든 확장 포트들을 이용할 수 있는 장점이 있습니다. (I2C LCD 모듈을 사용하거나, eMMC 슬롯도 사용할 수 있어요.) 대신에 한국어가 지원되지 않고, 가상머신 위 도커 설정에 오류가 발생하는 문제가 있더라구요. 한 일주일 설정해보다가 포기했습니다.   후에 뭔가 알려드릴 만큼 알게 되면 프록스목스 VE에 관한 내용도 작성해야 겠네요.  ","categories": [],
        "tags": ["ESXi","ODROID H2","하이퍼바이저"],
        "url": "http://0.0.0.0:4000/2019-09-29/ODROID-H2%EC%9A%A9-ESXi-6.7-%EC%84%A4%EC%B9%98-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A7%8C%EB%93%A4%EA%B8%B0",
        "teaser":null},{
        "title": "OMV4 자작 NAS 구축하기",
        "excerpt":"   openmediavault는 꽤 괜찮은 리눅스 기반의 오픈 소스 나스 솔루션입니다. 그래서 OMV4 기반의 자작 나스를 만들어보려고 해요.        openmediavault?     openmediavault 공식 홈페이지   openmediavault는 FreeNAS 프로젝트에서 파생된 Debian 기반의 오픈 소스 NASNetwork Attached Storage 솔루션입니다. 보통 줄여서 OMV라고 해요.   자작 나스 OS/솔루션 중에서는 기본기를 충실히 갖추고 있고, 데비안 기반이기 때문에 데비안/우분투 리눅스 사용 지식을 가지고 있으면 다루기도 쉬운 편이죠.   그리고 라즈베리파이, 오드로이드나 기타 파이류 등 다양한 SBCSingle Board Computer에 대한 지원도 충실한 편으로, 다양한 장비에서 설치해 볼 수 있는 장점이 있습니다.   Why “NOT” OMV5?   현재 OMV는 5버전이 비공식 릴리즈되어 있어요. 무슨 말인가 하면, 공식 홈페이지에서 OMV5의 릴리즈를 발표하지는 않았으나, 다운로드 페이지에 5.0.5 버전이 배포되고 있고, OMV5를 설치하는 스크립트도 공개가 되어 있습니다.   그런데 왜 OMV4의 설치를 안내하냐 하면, 다음과 같은 문제가 있기 때문입니다.   OMV5에서 플러그인 다수가 삭제     OMV5의 omv-extras.org 지원 플러그인 예정 목록   OMV5는 기반 OS가  데비안 9 (Stretch) 에서 데비안 10 (Buster) 로 변경된 것을 제외하고는 UI상 큰 변화는 없어요. 물론 데비안 10으로의 OS 업그레이드에 따른 패키지 버전 업데이트가 있으나, 체감할 만한 수준은 아닙니다.   가장 눈에 띄는 변경점은 플러그인 다수의 포팅이 종료되고 Docker를 사용하도록 권장되고 있다는 건데요. 이는 꽤 효율적인 판단이라고 생각합니다. 매년 OMV 메이저 업데이트에 따라 플러그인을 매번 포팅할 필요도 없고, 도커 네트워크의 질 좋은 서비스들을 끌어올 수도 있으니까요. 리눅스 기반 나스 솔루션이 선택할 수 있는 최선의 방법이기는 생각은 되지만…      “그럼 그냥 리눅스만 깔고 도커를 올리지 왜 OMV를 깔지?”    간단하게 OMV의 웹 UI로 나스를 컨트롤하고 싶은 초심자 입장에서는 영 불편합니다. 물론 플러그인 개발이 취소되고 도커로 전환된 서비스들도 사용하기 좋은 웹 UI를 가지는 이미지가 다수 배포되어 있지만, OMV 플러그인으로 관리하는 것이 (기능의 부실함을 감안하고서라도) 훨씬 편했거든요.   그러한 이유로 OMV4의 설치 가이드를 한참 늦은 시점에 작성하고 있습니다.     앞으로 할 내용들   다음과 같은 과정으로 OMV4 자작 나스를 만들 거에요.      디스크 마운트 및 공유 폴더 설정   그룹 및 사용자 추가, 공유 폴더 권한 부여   SMB 네트워크 드라이브 설정   FTP 설정   DuckDNS DDNS 설치   Transmission BitTorrent 클라이언트 설치   Nginx 역방향 프록시 설정   Let’s Encrypt SSL/TLS 인증서 적용   Docker 서비스 설치   여기서 설명하는 내용만으로도 충분히 쓸 만한 나스가 완성됩니다. 과정을 잘 이해한다면 응용하여 다른 서비스도 설치해 볼 수 있을 거에요.  ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["NAS","openmediavault"],
        "url": "http://0.0.0.0:4000/2019-10-06/OMV4-%EC%9E%90%EC%9E%91-NAS-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0",
        "teaser":null},{
        "title": "디스크 마운트 및 공유 폴더 설정",
        "excerpt":"   일단 공간을 만들어 놔야 뭘 담을 수 있겠죠?      OMV4가 설치되어 실행되게 되면 웹 브라우저에 IP를 입력하여 웹 패널에 접속하도록 합니다. 기본 ID와 비밀번호는 admin, openmediavault이에요. 웹 패널의 관리자 아이디는 admin 고정으로 바꿀 수 없습니다. 비밀번호는 일반 설정 &gt; 웹 관리자 암호 페이지에서 바로 바꾸는 것이 안전합니다.     파일 시스템 생성  디스크 확인   저장소 &gt; 디스크 페이지에 들어가면 현재 인식되어 있는 저장 장치의 목록을 볼 수 있습니다.      저는 데이터 저장 공간으로 /dev/sda에 연결되어 있는 장치를 사용할 거에요.   이제 저장소 &gt; 파일 시스템 페이지로 가서 이 디스크를 포맷하고 마운트합니다.   파일 시스템 확인      아까 확인한 디스크가 목록에 없는 것을 볼 수 있습니다. 생성 버튼을 눌러 파일 시스템을 생성합니다.   파일 시스템 생성      아까 확인해 둔 디스크를 선택하고 적당한 레이블 이름을 짓습니다. 파일 시스템은 EXT4가 기본값으로 설정되어 있어요. 시놀로지의 경우 BTRFS를 기본으로 선택하고 있는데, 서로 장단이 있으니 비교하여 선택하도록 합니다.   그리고 확인을 누르면 이제 포맷을 향한 긴 기다림이 있습니다. 경우에 따라 굉장히 오래 걸릴 수 있거든요.      이렇게 파일 시스템이 생성되었으면, 마운트 버튼을 눌러서 등록합니다. 마운트를 하지 않으면 공유 폴더에 등록할 수가 없어요!      [NOTE]     OMV는 시스템 파티션에 데이터를 저장하도록 허용하지 않습니다. 따라서 OMV (데비안) 를 설치하는 파티션과 데이터를 저장하는 파티션을 나누어서 설치해야 해요.     문제는 OMV 설치 이미지가 파티션 분할을 지원하지 않는다는 점입니다. 따라서, 단일 디스크에 OMV 설치와 데이터 보관을 같이 하려는 경우에는 Debian 9 (Stretch) 설치 후 OMV4 설치 스크립트를 실행하여 OMV4를 설치하는 편이 좋습니다.     데비안 9 설치 후 OMV4 설치 가이드 (스크립트 포함)    공유 폴더 추가   이제 마운트 된 파티션에 대해 공유 폴더를 설정할 차례입니다.   홈 디렉토리 생성 (Optional)   이 과정은 OMV에 대해 root 계정 외에 ssh 접속을 하려고 하거나, 이후 설정하는 SMB에서 홈 경로를 활성화하려는 경우 필요합니다. 홈 디렉토리 설정을 한 후 사용자를 추가해야 ssh 접속 시 명령어 자동완성을 사용할 수 있으니 가능한 설정하는 것이 좋아요.      이후의 과정은 사용자 생성 글에서 이어서 다룰게요. 이럴 거면 포스트를 합칠걸…   공유 폴더 추가   구성하려는 나스의 특성에 따라 공유 폴더를 추가합니다. 저는 이렇게 구성할 거에요.      (Optional) 사용자 홈 디렉토리   Contents 폴더. 관리자가 자료를 넣고 사용자는 읽을 수만 있습니다.   Public 폴더. 모든 사용자가 읽기/쓰기 가능합니다.   첫 번째 폴더를 만들어 봅시다.      위와 같이 설정하여 폴더를 생성합니다. 시놀로지와 다르게 OMV는 공유 폴더의 경로를 드라이브의 루트가 아닌 곳으로도 지정할 수 있어요. 이 점으로 인해 관리자용 메타 공유 폴더를 추가하거나, 사용자별로 개인 공유 폴더를 부여하는 등의 유연한 관리가 가능하지만, 반대급부로 폴더 권한이 꼬이기도 아주 좋습니다. 헷갈리지 않도록 구성하는 것이 중요하죠.   공유 폴더의 권한은 리눅스의 Owner-Group-Other 권한을 의미합니다. 따라서 위 그림의 권한은 관리자: 읽기/쓰기, 사용자: 읽기/쓰기, 기타: 읽기 전용, 즉 리눅스에서 말하는 rwxrwxr-x 또는 0775와 같아요. 그러나 OMV는 ACLAccess Control List이라고 하는 일종의 확장된 권한 관리 시스템을 사용하므로, 기본값을 수정할 이유가 별로 없는 것 같네요.   아무튼, 나머지 폴더도 위와 같이 만들면 이렇게 목록이 만들어집니다.      이제 폴더는 다 추가하였고, 이 폴더를 사용할 사용자들을 만들 차례입니다. 다음 글에서 계속할게요.  ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["NAS","openmediavault"],
        "url": "http://0.0.0.0:4000/2019-10-09/%EB%94%94%EC%8A%A4%ED%81%AC-%EB%A7%88%EC%9A%B4%ED%8A%B8-%EB%B0%8F-%EA%B3%B5%EC%9C%A0-%ED%8F%B4%EB%8D%94-%EC%84%A4%EC%A0%95",
        "teaser":null},{
        "title": "그룹 및 사용자 추가, 공유 폴더 권한 부여",
        "excerpt":"   좋은 것은 같이 봐야죠. 그러려면 사용자를 만들어야 합니다. 하지만 나만 보고 싶은 것도 있잖아요? 그래서 그룹도 만들어야 해요.      나스를 혼자 쓸 생각이라면 중요하지 않지만, 다른 사람도 사용하게 하고 싶다면 사용자 관리가 중요합니다. 리눅스는 원래 여러 사람이 사용할 수 있게 설계 되었기에 이 부분에 대해서는 잘 준비가 되어 있어요.     사용자 그룹 계획 세우기   권한을 사용자에게도 줄 수 있지만, 그렇게 관리했다가는 사용자가 조금만 늘어도 헷갈리기 시작할 거에요. 그래서 보통은 사용자들을 그룹에 소속시키고, 여기에 권한을 부여하여 사용하게 됩니다.   우리도 그렇게 해 봅시다. 저는  이렇게 세 개의 그룹을 만들었어요.      관리자 그룹 (Administrators). 모든 폴더에 대한 읽기/쓰기 권한을 가집니다.   사용자 그룹 (Members). 모든 폴더에 대한 읽기와, Public 폴더라는 곳에서는 쓰기도 가능합니다.   제한된 사용자 그룹 (Guests). Public 폴더에만 읽기 권한이 있습니다.   이렇게 만들어 보도록 할게요.   그룹 추가   접근 권한 관리 &gt; 그룹 페이지에서 그룹을 추가할 수 있어요.      이런 식으로 그룹을 추가합니다. 구성원은 나중에 사용자 페이지에서 추가할 생각이니 신경쓰지 않아도 됩니다. 어차피 아직 사용자를 안 만들었   나머지 그룹 생성 화면도 스크린샷을 찍기는 했는데요. 스크롤 낭비 같아서 생략합니다. 아무튼, 계획한 그룹을 모두 만들게 되면 아래와 같이 됩니다.      그리고 이제 사용자를 추가하러 가는데, 잠깐만요!   사용자 추가  홈 디렉토리 생성 (Optional)      저번에 하다 만 부분이 있었는데, 홈 디렉토리를 생성하는 부분입니다.   접근 권한 관리 &gt; 사용자 페이지의 설정 탭에 들어갑니다. 그리고 옵션 활성화를 하고, 홈 디렉토리 목적으로 만든 공유 폴더를 연결해 줍니다.   사용자 추가   이제 사용자를 추가합니다. 접근 권한 관리 &gt; 사용자 페이지에서 추가할 수 있어요.   일단 각 그룹별로 한 명씩 만들어 볼게요.      사실, 이름과 암호를 제외하면 필수로 입력하는 항목은 아닙니다.   이제 그룹도 설정해 볼까요.      관리자 목적으로 만든 사용자이므로 관리자 그룹을 선택해 줍니다. 이 화면에선 보이지 않지만, 사용자 생성 시 기본값으로 users 그룹이 체크되어 있는데요. 이를 그룹 권한 관리하면서 바꿔줄 수 있긴 하지만, OMV는 기본적으로 users 그룹으로 폴더나 파일을 생성하므로 굳이 체크를 해제할 필요는 없습니다.      [NOTE]     이 사용자를 통해 ssh를 사용하려고 한다면 일반 탭의 셸 부분도 신경 써주어야 합니다. 일반적으로 /bin/bash로 설정하면 크게 무리가 없어요.       그리고 ssh 그룹 (ssh 접속 허용) 과 sudo 그룹 (sudo 명령을 통한 root 권한 실행 허용) 도 추가시켜 주어야 합니다.   home 디렉토리를 만들지 않았으면 Tab 키를 통한 명령어 자동 완성이 지원되지 않으니, home 폴더도 만드는 것이 좋습니다.   공유 폴더의 접근 권한 관리   저번 포스트에서 만든 공유 폴더들에 정책에 맞는 접근 권한을 줍니다.   권한과 접근 제어 목록 두 가지가 있는데,      권한: 해당 공유 폴더가 서비스의 최상위 폴더로 노출되는 것에 대한 설정   접근 제어 목록: 실제 파일/폴더에 적용된 접근 권한   이라고 설명할 수 있습니다.   직관적으로 이해가 가지 않을 수 있는데요, 나중에 권한을 주지 않은 채로 접근 제어 목록에 권한을 준 뒤 FTP 등의 서비스로 접속해보면 무슨 의미인지 알 수 있습니다. 이 글의 구성에서는 양쪽을 다르게 설정할 이유가 없으므로, 두 설정의 내용을 똑같이 맞추어 주면 됩니다.   아무튼, Contents 폴더에 권한을 부여합니다. 아래의 폴더는 관리자 그룹에게는 읽기/쓰기를, 사용자 그룹에는 읽기만을, 그리고 제한된 사용자 그룹 (게스트)의 접근은 거부하는 구성이네요.      접근 제어 목록도 동일한 정책으로 수정합니다.      하단의 재귀적으로 - 파일과 디렉터리에 권한을 적용 옵션을 켜 주게 되면, 해당 폴더의 하위 파일과 폴더에도 같은 설정이 적용됩니다. 어색한 번역   자, 이제 폴더와 사용자 구성도 모두 끝났습니다. 이제 서비스를 설정하여 나스에 접속할 준비는 끝났습니다. 다음 글에서 서비스를 하나 설정해 보도록 합시다.  ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["NAS","openmediavault"],
        "url": "http://0.0.0.0:4000/2019-10-13/%EA%B7%B8%EB%A3%B9-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%B6%94%EA%B0%80,-%EA%B3%B5%EC%9C%A0-%ED%8F%B4%EB%8D%94-%EA%B6%8C%ED%95%9C-%EB%B6%80%EC%97%AC",
        "teaser":null},{
        "title": "SMB 네트워크 드라이브 설정",
        "excerpt":"   윈도우 홈 네트워크 아래서라면 SMB보다 편한 것은 없는 것 같습니다. 네트워크 드라이브가 지원되거든요.      SMBServer Message Block은 윈도우에서 파일이나 장치를 공유하기 위한 프로토콜입니다. 윈도우 탐색기의 네트워크에 들어가면 보이는 홈 네트워크상의 장치에 사용되는 프로토콜이라고 생각하면 될 거에요. SMB 프로토콜을 구현한 오픈 소스 소프트웨어 이름이 Samba인데요. 그래서인지 SMB 프로토콜 자체를 삼바라고 부르기도 하는 것 같네요.   아무튼 우리는 OMV의 SMB 설정을 환성화 한 후, 같은 홈 네트워크에 속한 윈도우의 네트워크 드라이브 연결 기능으로 연결시킬 겁니다.     호스트 이름 설정하기   시스템 &gt; 네트워크 페이지에서 호스트 이름을 설정합니다. 이건 사실 SMB하고는 직접적으로 상관은 없지만, 네트워크 드라이브를 편하게 연결하기 위해 필요해요.   그리고 기본적으로 여기서 설정한 이름이 네트워크 상에서 이 나스의 이름으로 쓰이므로, 알아보기 쉽게 지정하는 것이 좋겠죠.      간단하게 OMV4라고 이름을 지었습니다. 도메인 이름도 설정이 가능하긴 한데, 홈 서버 수준에서는 이것까지 설정하여 구분해야 할 이유는 별로 없습니다. 알림 서비스를 사용하여 OMV가 메일을 보낼 것이 아니라면 도메인 이름 설정은 생략해도 괜찮습니다.   SMB 활성화   그리고 서비스 &gt; SMB/CIFS 페이지에서 서비스 활성화를 합니다.      사실 이 아래에 몇 가지 설정이 더 있는데, 기본적인 사용에는 기본값에서 굳이 변경할 필요가 없으므로 스크린샷에 포함하지는 않았어요. 굳이 사용해 볼 만한 옵션이라면…      홈 경로 활성화: 사용자 홈 디렉터리를 활성화 시켰다면 이 옵션을 사용하여 사용자별 홈 폴더를 제공해 줄 수 있습니다. 소규모 사업장과 같은 곳에서 나스를 통한 개인별 백업 공간을 제공하려는 경우 유용할 수 있겠네요. 또는 가정에 여러 대의 PC를 여러 구성원이 사용할 때 개인 폴더로 활용하거나…   공유 폴더 추가   이제 공유 탭에 들어가서 아래와 같이 공유 폴더를 추가합니다. 이후에도 OMV에서 설정하는 대부분의 서비스에서 이와 같이 공유 폴더 추가하는 과정이 필요해요.      만들어 둔 공유 폴더를 선택할 수 있습니다. 저는 그림과 같이 Contents 폴더를 공유하고, 추가적으로 Public 폴더도 공유하도록 할게요.   home 폴더는 이렇게 공유하면 안 됩니다! 앞에서 홈 경로 활성화를 해주었으면 여기서 추가하지 않아도 자연스럽게 사용자별로 제공이 된거든요. 오히려 공유하면, 경우에 따라 모든 사용자가 다른 사용자 홈 폴더에 접근하게 될 수도 있습니다!      사용할 공유 폴더를 모두 추가하고 나면 이렇게 목록을 확인할 수 있어요.   네트워크 드라이브 연결하기      윈도우의 내 PC에 들어가면 상단 탭에 위와 같은 메뉴들이 있습니다. 네트워크 드라이브 연결을 눌러 설정을 시작합니다.      적당한 드라이브 이름을 할당하고 폴더 경로를 입력합니다. 폴더 경로는 \\\\호스트 이름\\공유 폴더 이름 과 같이 설정할 수 있어요. 또는 \\\\나스 IP\\공유 폴더 이름 과 같이 설정해도 됩니다. 로그인할 때 다시 연결 옵션을 선택하면 재부팅 후 자동으로 연결이 되고, 윈도우와 나스의 계정 정보가 다를 경우 (대부분 다를 겁니다.) 다른 자격 증명을 사용하여 연결을 선택하여 계정 정보를 직접 입력하도록 합니다.   저는 호스트 이름을 OMV4 라고 지었으므로 O 드라이브를 할당하고, Contents 폴더를 연결할 예정이므로 \\\\OMV4\\Contents 라고 경로를 입력했어요.      그럼 이렇게 자격 증명을 입력하는 화면이 나오는데, OMV의 사용자 정보를 입력하면 됩니다.   정상적으로 입력이 완료되면 네트워크 드라이브가 연결된 후, 연결된 공유 폴더가 새 창으로 나오게 됩니다. 그럼 끝!      [NOTE]     가끔 사용자 정보를 정상적으로 입력해도 계정 정보가 일치하지 않는다는 메시지와 함께 연결이 되지 않는 경우가 있습니다. 여기에는 다양한 원인이 있을 수 있으나, 정상적으로 구성하였는데도 그런 상황이 발생한다면, OMV 웹 패널의 접근 권한 관리 &gt; 사용자 페이지에서 해당 사용자의 비밀번호를 다시 설정해 보세요. 그 후에 정상적으로 되는 경우가 종종 있었습니다.     아마도 리눅스 사용자 비밀번호가 SMB에 정상적으로 동기화되지 않는 문제인 것 같네요.   ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["NAS","openmediavault","SMB"],
        "url": "http://0.0.0.0:4000/2019-10-26/SMB-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EC%84%A4%EC%A0%95",
        "teaser":null},{
        "title": "FTP 설정",
        "excerpt":"   FTP만 잘 설정되어 있어도 나스를 통한 파일 전송은 대부분 해결됩니다. 괜히 이름이 File Transfer Protocol이 아니거든요.      FTPFile Transfer Protocol는 네트워크에서 가장 유명한 파일 전송 방법입니다. 이름이 파일 전송 프로토콜이니까   유명한 프로토콜이라 거의 대부분의 환경에서 이를 지원하므로, 나스라면 반드시 깔아야 할 서비스라고 볼 수 있습니다.   이 글을 통해 서버를 설정한 후,      FileZilla를 통해 단순히 나스의 파일을 관리할 수도 있구요,   RaiDrive를 설치해 집 밖에서도 아예 네트워크 드라이브처럼 쓴다거나,   CX 파일 탐색기와 같은 안드로이드 탐색기 앱에 연결시켜 쓸 수도 있고,   FolderSync를 설치하여 스마트폰과 나스의 데이터를 동기화 시킬 수도 있습니다.   결론은, 대부분의 파일 관리 서비스는 FTP를 지원하므로, 그 활용 가치가 높습니다. 빨리 깔아봅시다.     FTP 활성화하기      서비스 &gt; FTP 페이지에서 서비스를 활성화합니다. 여러 일반 설정이 있는데,      포트: FTP를 서비스할 포트를 지정합니다. 기본값은 21인데, 이 포트번호는 매우x100 유명한 번호 중 하나이므로, 적절한 보안 대책이 없다면 다른 번호로 바꿔줘도 좋습니다.   최대 클라이언트: 나스에 동시 접속할 FTP 클라이언트의 최대 숫자입니다. 나스 성능과 나누어 준 사용자 아이디를 고려하여 적당히 설정합니다.   호스트당 최대 연결: 1개 접속자에서 얼마나 많은 연결을 가져갈 수 있는지에 대한 설정입니다. “어차피 1개 아니야?” 싶지만, FTP를 통해 영화+자막을 스트리밍한다거나, 이전 연결이 비정상적 종료되어 서버가 아직 끊어진 줄 모른다든지 하는 이유로 더 많이 필요할 수도 있어요. 적당한 크기로 잡아둔 뒤, 나스 사용 패턴을 확인하여 FTP 연결이 거부되거나 끊긴다 싶을 때 이 값을 조금씩 올려주면 됩니다. 아니면 처음부터 넉넉하게 설정하거나요.   최대 로그인 시도 횟수: 설명 그대로인데, 1로 둡니다. 딱히 변경해야 하는 이유를 모르겠어요…   익명 FTP 활성화: 이 옵션을 켜면 Anonymous 로그인이 가능해지는데 (일반적으로 ID를 메일 주소로 넣는다고 해요.), 우리는 공개된 FTP서버는 아니니 활성화 할 필요는 없습니다.   환영 메시지: FTP에 접속하게 되면 나오는 메시지! 인데… CLI 환경이 아닌 이상 이를 표시해 주는 클라이언트가 거의 없습니다.   아래 옵션도 읽어봅시다.      다른 옵션들은 크게 관심이 없고, (대역폭 제한이나 다시 시작, 전송 기록 정도가 쓸 만합니다.) 수동 FTP 설정을 알아볼 필요가 있는데요. 이 옵션을 켜지 않으면 나스가 알아서 포트를 설정하지만, 우리는 공유기 아래에 나스를 두고 서비스할 것이므로 이 범위를 지정해 줄 필요가 있습니다.   저는 활성화 시 기본으로 잡혀 있는 49152:65534 대역을 사용하기로 했습니다. 만약 해당 범위에 다른 서비스 포트가 포함된다면 다른 범위로 잡아주세요.   공유 폴더 추가   SMB 설정을 했다면 큰 설명이 필요 없는 과정입니다. 그림 두개로 끝낼게요.      이렇게 Contents 폴더를 추가하고, 같은 방법으로 Public 폴더도 추가시키면      위와 같은 화면이 나오며 완성!   FileZilla로 확인하기   앞에서 얘기했듯 FTp를 사용하는 프로그램은 정말 많이 있는데, 일단 FileZilla를 사용해 봅시다.      이런 식으로 나스의 IP (또는 도메인), 사용자명과 비밀번호, 포트를 넣고 연결하면,      이렇게 공유 폴더가 뜨는 것을 확인할 수 있습니다.     그리고 남은… 아니 이게 더 중요한 것 같은데?   물론 홈 네트워크 내부에서만 사용하려고 했으면 FTP를 설정할 필요까지는 없습니다. 그래서 SMB를 먼저 했죠?   이 단계에서는 공유기 외부에서도 나스의 FTP에 접속할 수 있도록 포트포워딩 설정을 할 건데요. ipTIME과 ASUS 공유기 2종류에 대해서 설정하는 법을 보여드리는데, 다른 공유기도 비슷한 과정으로 포트포워딩 메뉴에서 쉽게 설정할 수 있습니다.   ipTIME 포트포워딩 설정   NAT/라우터 관리 &gt; 포트포워드 설정에서 할 수 있어요.      이건 FTP 제어 포트,      이건 FTP 데이터 통신 포트 설정입니다. OMV에서 설정을 바꾸어줬다면 여기에서도 동일하게 적어주어야 해요.   ASUS 포트포워딩 설정   ASUS 공유기는 WAN &gt; 가상서버 / 포트 포워딩 페이지에서 설정할 수 있어요.      마찬가지로 FTP 제어 포트,      FTP 데이터 통신 포트 설정입니다. 내부 포트 번호를 적지 않으면 외부와 같은 포트번호로 자동 포워딩된다는 의미입니다.   이렇게 설정한 후, 공유기의 외부 IP/도메인과 외부 포트번호를 가지고 연결이 되는지 확인하면 됩니다.     그리고 진짜 남은 이야기   지금은 공유기 외부에서 접속할 때 인터넷 사업자가 제공해 준 공유기의 공인 IP를 사용하고 있는데, 일반적인 가정집의 경우 이 번호가 주기적으로 바뀝니다. 언제 바뀔지도 모르는 이 번호를 통해서 외부 접속을 할 수는 없으니, DDNSDynamic Domain Name System 설정을 해야 해요. 그리고 앞으로 설명할 서비스들이 대부분 외부 접속을 염두에 두고 있구요.   그래서 다음 글은 공유기에서 DDNS 설정하는 방법이 되겠습니다.  ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["FTP","NAS","openmediavault"],
        "url": "http://0.0.0.0:4000/2019-10-27/FTP-%EC%84%A4%EC%A0%95",
        "teaser":null},{
        "title": "DuckDNS DDNS 설치",
        "excerpt":"   언제까지 IP를 입력해서 서비스를 사용할 수는 없습니다.      DDNSDynamic DNS란 유동 IP에 대해 DNSDomain Name System를 제공하는 방법입니다. DDNS 서버에 주기적으로 IP 갱신 요청을 보내, 설령 해당 도메인의 IP가 변경되었더라도 빠르게 이를 반영하는 방식으로 동작합니다.     사실 이건 OMV에서 제공하지 않는다   사실 이 글을 주제에 넣는게 맞는지 고민을 했습니다. 왜냐하면 이건 OMV에서 지원하는 서비스가 아니거든요. 하지만 외부 접속이 필요한 시점에서 도메인은 꼭 필요한 것이 되므로, 나스의 설치를 위해서라면 꼭 필요한 과정이라고 생각해서 넣었습니다.   그리고 굳이 이 글의 방법으로 DDNS를 설치할 필요도 없는데요.   공유기에서 DDNS 서비스를 지원한다   사실 DDNS는 홈 네트워크를 외부에서 쉽게 접속하기 위한 방법이고, 이 방법을 위해서는 24시간 동작하는 컴퓨팅 장비가 필요하기 때문에, 이 조건을 충족하는 장비인 공유기에서도 DDNS를 지원합니다.   ipTIME의 경우 iptime.org와 ipdisk.co.kr를 제공하고 있고, ASUS의 경우 asuscomm.com 이름으로 제공하며, 그 외 다른 유명 DDNS 연결도 지원하고 있어요.   하지만 우리 역시 24시간 돌아가는 나스가 있으니! 공유기별 방법 다 안내하기도 귀찮고 나스를 통하여 설치하는 방법을 소개하겠습니다.   Duck DNS      Duck DNS는 무료 DDNS 서비스 중 하나입니다.   다른 DDNS 서비스도 있지만, Duck DNS도 꽤 안정적인 서비스이고 서브도메인에 대한 연결도 지원하고 있으므로 나스용으로는 꽤 괜찮은 것 같아요. 그리고 DDNS 갱신도 쉬운 편이에요.   우선, 가입 후 도메인 등록부터 해 봅시다.   Duck DNS에 도메인 등록      소셜로그인으로 로그인하고 나면 위와 같은 화면이 뜹니다. 토큰은 개인정보로 DDNS 갱신에 필요하니 외부에 노출시키는 일이 없도록 주의합니다. 누가 대신 갱신해 버릴수도   그리고 하고 싶은 도메인을 적은 뒤 add domain 버튼을 누르면, 중복 검사가 완료된 후에,      이렇게 도메인이 등록됩니다!   이 작업을 하는 컴퓨터와 나스가 같은 공유기 아래 있다면, update ip 버튼을 눌러 DDNS와 IP를 연동시킬 수 있어요. 그러므로 앞으로 5분마다 이 사이트에 접속하여 저 버튼을 눌러주면 됩니다 :) 다음 글은 5분마다 갱신 버튼을 누를 불침번을 정하는 방법입니다.   5분 마다 이걸 눌러줄 수는 없으니, 나스가 자동으로 갱신하게 해야겠죠.   NAS에 자동 갱신 설정하기      사실 Duck DNS에서 시스템별 자동 갱신 방법을 제공하고 있어요. Duck DNS Install   이 방법 그대로 따라해봅시다. 우선 ssh에 접속해서,   $ sudo mkdir -p /root/duckdns $ sudo vi /root/duckdns/duck.sh   root의 홈 디렉토리 아래에 duckdns 폴더를 만들고, 그 아래 duck.sh 파일을 만들어 편집합니다. 그리고 파일에 다음과 같이 내용을 넣으세요.   echo url=\"https://www.duckdns.org/update?domains={사용 도메인}&amp;token={할당받은 토큰}&amp;ip=\" | curl -k -o ~/duckdns/duck.log -K -   그리고 root 유저가 실행할 수 있도록 권한을 조정합니다.   $ sudo chmod 700 /root/duckdns/duck.sh   그리고 시스템 &gt; 예약된 작업에서 이 스크립트를 추가합니다.      스크립트가 한번 실행되고 나면 등록된 DDNS 주소로 나스에 접속할 수 있습니다.   혹시 공유기의 설정 페이지가 뜬다면 공유기의 포트포워딩 설정을 수정하고, 아예 연결이 되지 않는다면 Duck DNS 사이트에 접속하여 공인 IP가 정확하게 등록되었는지 확인해 봅시다.     그리고 사실 남은 이야기   원래 갱신 스크립트를 생성하고 이를 예약 실행하는 복잡한 방법만 알고 있었는데, 이번에 글을 쓰기 위해 알아보다가 그만…   freenas용 인스톨 방법을 활용한 간단 설정법을 알게 되었어요.   방법은 매우 간단하합니다. 다음의 스크립트를 예약된 작업의 명령에 추가시켜주면 된다. 프리나스와는 curl 명령의 위치가 다르므로 /usr/local/bin/curl만 /usr/bin/curl로 바꾸어 줍니다. 혹시 curl이 설치되지 않은 경우에는 $ sudo apt-get install curl 명령을 통해 curl을 설치해 주세요.   /usr/bin/curl http://www.duckdns.org/update/{사용 도메인}/{할당받은 토큰}   그리고 아래와 같이 설정해 주면…      되네요. 앞에 쓴 글 다 날아가는 소리   저도 지금은 이 방법으로 쓰고 있습니다.  ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["DDNS","NAS","openmediavault"],
        "url": "http://0.0.0.0:4000/2019-11-10/DuckDNS-DDNS-%EC%84%A4%EC%B9%98",
        "teaser":null},{
        "title": "Transmission BitTorrent 클라이언트 설치",
        "excerpt":"   공유자가 얼마 없는 토렌트도 세월아 네월아 기다리다 보면 다 받을 수 있는 법입니다. 물론 컴퓨터가 세월아 네월아 켜져 있어야 하죠. 그런데 우리는 나스가 있잖아요?      BitTorrent는 파일의 공유를 위한 P2P 프로토콜입니다. 파일을 다운받는 사용자를 동시에 다운받은 부분에 대한 업로더로 활용, 해당 파일에 대한 업로드 자원을 확장시켜 다운로드 속도를 확보하며 빠르게 파일을 확산시키는 방식이죠.   비트토렌트는 고성능의 배포 서버를 확보하기 어려운 프로그램의 배포에 활용되는 경우가 종종 있습니다. 게임 클라이언트라거나, 오픈소스나 개인 제작자의 파일 배포 등에요. 네, 사실 가장 많이 쓰이는 분야는 방송 등 미디어 컨텐츠에 대한 공유일 거에요. 그걸 어떻게 하는지는 알아서 찾아봅시다.   그래서 이 글에서는 Transmission이라고 하는 비트토렌트 클라이언트를 설치하여 토렌트를 통해 파일을 다운받거나 공유하는 방법을 안내합니다.     Transmission 설치   일단 트랜스미션을 다운받습니다. OMV4까지는 이를 플러그인으로 지원하기 때문에 매우 쉽게 설치할 수 있어요.   아래 그림과 같이 시스템 &gt; 플러그인 에서 transmission 패키지를 찾아 설치합니다.      토렌트 관리 폴더 설정   토렌트를 받기 위해서는 아래와 같이 세 개의 폴더를 만들어야 합니다.      complete (완료된 토렌트 파일을 보관할 폴더)   incomplete (다운로드 중인 토렌트 파일이 저장될 폴더)   watch (다운로드할 토렌트 시드를 저장할 폴더)   이 중 incomplete, watch 폴더는 만들지 않아도 됩니다. incomplete 폴더를 만들지 않으면 complete 폴더에 같이 저장되게 되고, watch 폴더가 없으면 시드 파일을 복사하여 토렌트를 받는 방식을 사용할 수 없어요.   저는 토렌트 전용 공유폴더를 생성하여 설치를 진행하기로 했습니다.      위와 같이 공유 폴더를 생성하고, FTP나 SMB, SSH 등으로 이 아래에 위에서 말한 3개의 폴더를 생성합니다.   그리고 트랜스미션 프로그램이 이 폴더에 접근할 수 있도록 권한을 줍니다.      BitTorrent 설정   플러그인을 설치하고 나면 서비스 &gt; BitTorrent라는 메뉴가 생긴 것이 보일 거에요. 해당 메뉴에 들어간 뒤, Files and Locations 탭부터 확인합니다.      아까 만든 폴더들을 위 그림과 같이 연결합니다. 그리고 RPC 탭으로 갑니다.      트랜스미션 RPC는 트랜스미션을 관리하는 웹 패널이에요. RPC를 활성화시킨 후 나스의 해당 포트로 접속하게 되면 µTorrent처럼 토렌트를 관리할 수 있습니다.   그리고 이 설정은 Transmission Remote과 같은 외부 관리 툴에서도 필요해요.      그리고 트랜스미션을 활성화해주면 끝입니다.   Transmission을 통해 토렌트 다운받기   자, 이제 토렌트를 받아봅시다.      웹 브라우저에 NAS주소:포트번호로 접속하여 트랜스미션 RPC에 접속하면 위와 같은 화면을 볼 수 있습니다. 열기 아이콘을 눌러 토렌트 받기를 시작할 수 있어요.   첫 번째 방법, RPC에 시드 파일을 추가하기      인터넷에서 받은 .torrent 시드 파일을 파일 선택 버튼을 통해 추가할 수 있습니다.   두 번째 방법, RPC에 마그넷 주소 붙여넣기      아니면 magnet: 으로 시작하는 링크를 붙여넣어 토렌트를 다운받을 수도 있구요.   세 번째 방법, Watch 폴더에 시드 파일을 복사하기   아까 만들어 둔 watch 폴더에 .torrent 파일을 복사하여 다운로드를 진행할 수도 있어요. 파일을 복사한 뒤 트랜스미션이 시드를 확인하면, 토렌트를 추가하고 파일을 .added 확장자로 바꿔놓습니다.      FTP를 통해 시드를 복사해 놓은 장면입니다. 복사 직후 토렌트가 파일을 인식하여 .added 파일로 바꿔놓았네요.   아무튼 이렇게 파일을 추가하고 나면,      이렇게 토렌트가 추가되어 다운로드 중인 것을 확인할 수 있습니다. 다운로드 중에는 incomplete 폴더에 .part 확장자로 파일이 받아지다가,      다운이 완료되면 complete 폴더에 이렇게 받아져 있는 것을 볼 수 있어요.     그리고 남은 이야기   이 시리즈의 시작 부분에서 언급한 내용이지만, OMV5에서는 플러그인이 삭제되어 트랜스미션을 위와 같이 설정할 수 없습니다.   OMV가 커뮤니티에서 개발하는 솔루션이므로 도커와 같은 외부의 구축 방식을 사용하는 것이 플러그인 개발 부담이 적긴 하겠지만, 트랜스미션 정도는 핵심 기능으로 고려하고 플러그인을 개발하는 것이 좋았지 싶습니다. 아쉽네요.  ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["BitTorrent","NAS","openmediavault","Transmission"],
        "url": "http://0.0.0.0:4000/2019-11-24/Transmission-BitTorrent-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%84%A4%EC%B9%98",
        "teaser":null},{
        "title": "Nginx 역방향 프록시 설정",
        "excerpt":"   웹 브라우저를 통해 나스에 접속하는 서비스가 두 개 이상이라면 슬슬 설정할 때가 되었다는 뜻입니다.      지난 번에 트랜스미션을 설치하며, 웹 브라우저로 접속하는 서비스가 2개가 되었습니다. (OMV 웹 설정 패널, 트랜스미션 RPC)   이 서비스들을 사용하기 위해서 포트번호를 외우고 다니는 것도 나쁘진 않지만, 뭔가 전문적인 느낌을 위해 Nginx의 역방향 프록시를 사용하여 서브도메인으로 서비스를 관리해 봅시다.     역방향 프록시란   역방향 프록시란 HTTP 서비스에서 실제 서버 자원의 통신을 대리하는 서버입니다. 왜 역방향Reverse이라는 이름이 붙었나면, 원래 프록시 서버Proxy Server는 클라이언트의 네트워크에 붙어 클라이언트를 대리하는 서버를 말하거든요. 그런데 얘는 서버를 대리하여 반대 방향으로 프록시 역할을 수행하니, 역방향 프록시인 겁니다.   물론 고작 나스를 운영하는 입장에서는 그런 원론적인 개념을 이해할 필요는 없고, 우리는 이 기능을 사용하여      서브도메인을 사용하여 서비스에 접속하고,   HTTPS 적용을 쉽게 할 수 있습니다. (이건 다음 글에서 다룰 거에요.)   정도가 가능해진다고만 알면 될 것 같네요.   사전 작업   앞의 글들을 읽었다면 이해하기 어렵지는 않습니다. 또는 이미 설정되어 있을 수도 있어요.   DNS 서비스 설정   일단, 서브도메인이 지원되는 도메인이 필요합니다. 도메인을 구입하였다면 모든 서브도메인을 나스로 연결되도록 네임 서버를 설정해주고, 아니면 DDNS를 사용합니다. 테스트해 보니, iptime.org은 안 되고 duckdns.org가 서브도메인을 지원하네요.   공유기 포트포워딩 설정      지금까지 홈네트워크 바깥에서는 FTP만 사용하게 했었는데, 역방향 프록시를 위해서는 HTTP도 외부에 공개되어야 합니다. 80 포트를 통한 접속이 나스에 중계되도록 공유기에 설정합시다.   OMV 패널 접속 포트 변경   Nginx가 나스의 기본 HTTP 포트인 80 포트를 사용할 건데요, 그럼 OMV 패널과 포트가 겹쳐요. 그래서 시스템 &gt; 일반 설정에서 포트를 적당한 것으로 바꿔줘야 합니다.      저는 포트 번호를 8080으로 바꿨어요.   Nginx 설치   Nginx는 유명한 웹 서버 패키지로 워드프레스 등 다른 웹서비스를 위해 사용됩니다. 그렇지만 우리는 이걸 단순히 역방향 프록시용으로만 활용할 거에요. 물론, 나중에 서버를 추가하여 웹서비스용으로도 사용할 수 있습니다.   시스템 &gt; 플러그인 메뉴로 들어가 엔진엑스를 설치합니다.      설치가 완료되면 서비스 메뉴에 Nginx (websites) 메뉴가 생성되어 있습니다. 활성화 시켜줍니다.      이 때, 서버 이름 해시 버킷 크기를 최대치로 올려 주는 것이 좋다고 합니다. 이 크기가 작으면 URL이 길어질 경우 오류가 날 수 있대요. 오류를 경험해 본 적은 없지만, 우리의 나스가 이걸 작게 유지해야 할 정도로 성능이 낮은 것은 아니니 높게 잡아줍시다.   Nginx 서버 추가하기   이제 서버 탭에 들어가서 서비스를 추가합니다. 2개의 프록시 서버를 추가할 건데요.      cpanel.banyazavi.duckdns.org (OMV 제어 패널)   torrent.banyazavi.duckdns.org (트랜스미션 RPC)      마지막의 추가 옵션이 매우 중요합니다. 사실 이 내용이 이번 글의 핵심인데요. 8080 포트로 설정한 OMV 제어 패널로 예를 들면,   location / {   proxy_pass http://localhost:8080; }   이 구문의 의미는 서버 이름으로 접속하여 하위 주소가 /일 경우, Nginx의 입장에서 http://localhost:8080으로 접속한 내용을 서비스한다는 의미입니다.   나중에 다른 서비스를 설치하였다면, 8080대신 해당 서비스의 포트 번호를 입력하면 됩니다. 나스 내부에 설치된 서비스가 아니라면 localhost 부분도 다른 IP나 주소로 바꾸어 주세요.   설정이 완료되었다면 등록한 주소로 접속하여 서비스가 제대로 뜨는지 확인해 봅시다.     그리고 남은 이야기   서브도메인을 지원하지 않는 iptime.org와 같은 DDNS의 경우, 하위 경로를 구분하여 서비스를 쪼개 주는 방법이 가능은 한데요, 추가 옵션이 매우 복잡해집니다. 예전에 간신히 적용에 성공해 본 적이 있긴 한데, 마냥 원활하게 굴러간 것도 아니었으므로 알려 드리긴 어렵고, 사실 까먹음 왠만하면 서브도메인을 통해 사용하는 것이 편해요.   그리고 Nginx도 OMV5에서 플러그인이 삭제됐습니다. 대신 도커에 역방향 프록시를 지원하는 좋은 이미지들이 많으므로 이 쪽을 쓰는 것이 좋겠네요.  ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["NAS","Nginx","openmediavault","Reverse Proxy"],
        "url": "http://0.0.0.0:4000/2019-12-01/Nginx-%EC%97%AD%EB%B0%A9%ED%96%A5-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%A4%EC%A0%95",
        "teaser":null},{
        "title": "Let's Encrypt SSL/TLS 인증서 적용",
        "excerpt":"   웹 브라우저를 통해 나스에 접속했을 때, ‘주의 요함’ 이라는 메시지가 뜨면 조금 그렇겠죠?      SSLSecure Socket Layer는 네트워크 보안 방식 중에 하나입니다. TLSTransport Layer Security라는 이명으로도 많이 알려져 있는데, 네트워크의 전송(Transport)계층에 보안을 적용시켜 그 상위 계층 프로토콜인 HTTP, FTP의 보안 전송을 가능하게 하죠.   아무래도 보안을 적용시키는 일이니만큼 약간의 속도 하락을 피할 수는 없으나, 요즘의 웹 브라우저는 보안 인증이 되어 있지 않은 페이지에는 경고를 발생시키는 등, 보안 장치가 되어 있지 않은 사이트의 이용을 엄격하게 제한하는 편이니 적용하는 편이 좋아요.     Let’s Encrypt   Let’s Encrypt 공식 홈페이지   TLS 인증서는 어떤 도메인에 대해 인증기관이 해당 도메인에 대한 인증키를 도메인 운영자에게 제공하고, 도메인에 이를 탑재하여 안전한 사이트임을 인증받게 되는 구조입니다. 즉, 브라우저가 인정하는 인증기관 - 인증기관이 인증하는 도메인과 인증서 - 인증서를 탑재한 도메인의 3박자가 맞아 돌아가며 사이트를 인증하는 방식이에요.   Let’s Encrypt는 TLS 인증서를 무료로 발급해주는 기관입니다. DVDomain Validate 방식의 인증서를 발급하여 프로그램에 의한 자동화가 가능하기 때문에, 나스에서 이를 쉽게 발급받아 활용할 수 있습니다.   사전 작업   홈 네트워크 외부와 뭘 하려면 공유기에 포트포워딩 설정을 해 주어야 한다는 사실은 이제 익숙하죠?   공유기 포트포워딩 설정      HTTPS 서비스는 기본적으로 443 포트를 사용합니다. 이제 포트를 나스에 중계시키는 포트포워딩 규칙을 설정해 줍시다.   Let’s Encrypt 설치   시스템 &gt; 플러그인 메뉴로 들어가 Let’s Encrypt를 설치합니다.      이제 서비스 메뉴에 LetsEncrypt 메뉴가 보이네요. 기본 설정을 위해 설정 탭으로 들어갑니다.      이후에 발급발을 인증서의 자동 갱신을 위해 Schedule Refresh를 활성화하고, 인증을 위한 메일 주소와 인증서 이름을 설정합니다.   RSA Key Length는 더 크게 설정할 수도 있는데, 그만큼 보안 인증에 CPU 자원이 더 소모되니 적당한 수준에서 설정합시다.   인증 도메인 추가 및 인증서 생성   Domain 탭에서 인증서를 발급받을 도메인을 추가합니다. 저는 저번에 추가한 2개의 서비스에 FTP까지 총 3개를 만들 예정이에요.      cpanel.banyazavi.duckdns.org (OMV 제어 패널)   ftp.banyazavi.duckdns.org (FTP)   torrent.banyazavi.duckdns.org (트랜스미션 RPC)      인증할 도메인들을 ,로 이어 붙여줍니다. 한번에 100개 정도까지 가능하다고 합니다. 100개까지 쓸 일이… 이때 도메인 인증을 위한 Web Root는 OMV의 루트 경로인 /var/www/openmediavault/로 지정해주면 됩니다.   그러면 목록에 인증할 도메인이 목록에 뜨게 되는데, 다음과 같이 인증서 &gt; Generate 버튼을 눌러 인증서를 발급받아 봅시다.      인증서가 무사히 생성되었으면 아래와 같은 메시지가 나오며 완료됩니다.      자 이제 서비스에 적용시켜 보자!   FTP에 SSL/TLS 적용   FTP부터 연결시켜 봅시다. 서비스 &gt; FTP &gt; SSL/TLS 탭에 들어가서 아래와 같이 설정합니다.      고급 설정의 네 가지 항목들은 사용하는 FTP 서비스가 정상적으로 동작하지 않을 때 바꿔 보며 테스트해 보세요. Required를 끄게 되면 평문 FTP로도 통신할 수 있으므로 실제로는 FTP가 적용되지 않은 것일 수도 있다는 점 주의하세요. 묵시적 SSL은 FTP 클라이언트에서 Implicit이라고 불리는 보안 모드인데, 간혹 이 모드로 연결이 필요한 경우가 있습니다.   웹 사이트에 SSL/TLS 적용하기   시스템 &gt; 일반 설정 메뉴에 가면 OMV 관리 페이지도 FTP와 비슷하게 인증서를 추가할 수 있습니다. 그런데 우리는 이미 엔진엑스를 통한 역방향 프록시로 관리 페이지에 접속하고 있으므로, 이 곳에서 설정하는 것이 더 편해요.   서비스 &gt; Nginx (websites) 페이지에 들어가서, 이전에 추가해놨던 서버 설정의 SSL 부분을 아래와 같이 편집합니다.      Only use SSL 설정을 켜 주면 HTTPS로만 접속할 수 있습니다. 이 경우에 HTTP로 접속하게 되면 접속을 거부하게 돼요.     그리고 남은 이야기   이제 OMV4를 이용한 기본적인 나스 구축은 완료되었습니다. 지금까지의 과정을 잘 따라왔다면 다른 서비스들도 플러그인 페이지에서 조회하여 설치하고, 각 서비스 페이지에서 세부 설정하는 방식으로 사용할 수 있어요.   플러그인이 지원되지 않는 서비스들은 SSH로 직접 접속하여 리눅스에 서비스를 설치하는 방법을 따라하여 설치할 수 있는데요, 이는 서버의 하드웨어 특성을 심하게 타기 때문에 일관적인 가이드가 어렵습니다.   그래서 요즘은 이런 문제를 피하기 위해 Docker를 이용하여 서비스를 배포하는 경우가 많아졌어요. 그래서 다음 글은 도커를 사용하는 방법에 관한 이야기입니다.  ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["Let's Encrypt","NAS","openmediavault","SSL","TLS"],
        "url": "http://0.0.0.0:4000/2019-12-14/Let's-Encrypt-SSL-TLS-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%A0%81%EC%9A%A9",
        "teaser":null},{
        "title": "Docker 서비스 설치",
        "excerpt":"   도커를 사용하게 되면 OMV 플러그인에 한정되지 않는 수많은 서비스를 설치할 수 있습니다. 그리고 요즘은 도커로 배포되는 서비스도 많아졌어요.      Docker는 컨테이너 기반의 리눅스 가상화 도구입니다… 라고 업계 용어로 표현하면 선뜻 다가가기가 힘들죠. 우리는 그저 나스를 구축하고자 할 뿐이니까, 쉽게 다시 정의해봅시다.   Docker는 서버 환경에 관계 없이 동일한 방법으로 서비스를 설치할 수 있게 하는 플랫폼입니다.   음, 아직도 어렵지만 우리의 목적에 맞는 표현은 된 것 같아요.     Docker?     Docker 공식 홈페이지   앞의 정의를 다시 가져옵시다. Docker는 컨테이너 기반의 리눅스 가상화 도구입니다. VMWare나 VirtualBox 같은 가상 머신과는 다른 개념이지만, 가상화라는 점에서는 비슷한 도구라고 볼 수 있겠네요.   근데 도커와 같은 가상화가 왜 나스와 같은 개인용 홈서버 구축에 획기적인 도구가 되었을까요? 그건 일단 도커만 설치가 잘 되었다면, 컨테이너 (가상화 공간) 내부는 완벽하게 제작자 의도대로 돌아가는 공간이 되어 있기 때문입니다. 따라서 환경별 차이로 발생하는 설치 문제에 일일이 대응할 필요가 없어지므로, 제작자와 사용자 모두에게 편리한 설치 환경을 제공할 수 있습니다.   OMV4에 Docker 설치하기   OMV4는 Docker CE의 플러그인을 제공하고 있어요. 시스템 &gt; OMV-Extras 페이지의 저장소 탭에서 이를 활성화 시켜줍니다.      그리고 이제 시스템 &gt; 플러그인 페이지에 들어가면 아래와 같이 Docker 패키지가 추가되어 있어요. 설치합니다.      설치하고 나면 서비스 &gt; Docker 메뉴가 추가된 것이 보입니다. 메뉴에 접속하기 전에 Docker 시스템에서 사용하는 데이터를 넣어 둘 공간을 만들어야 하는데요, 이를 위해 공유 폴더 하나를 생성합니다.      사실, 이 폴더를 만들지 않고 OMV 내부의 운영체제 공간에 이를 생성하게 할 수도 있어요. 그리고 이 폴더는 우리가 직접 들어가 볼 이유도, 권한도 없으므로 그 편도 나쁘지 않습니다. 다만 이 공간의 용량이 설치하는 도커 서비스에 따라 굉장히 유동적일 수 있으므로, 운영체제 공간의 용량이 부족하다고 생각한다면 넉넉한 곳에 공유 폴더를 생성하여 잡아주도록 합시다.   이제 서비스 &gt; Docker 페이지에서 도커 서비스를 활성화시킵니다.      쨘! 그럼 이제 아래와 같이 도커가 활성화되어 준비중인 것을 볼 수 있습니다.      이제 도커를 사용할 준비가 끝났네요. 이제 컨테이너를 설치해 봅시다.   Docker 컨테이너 설치   도커를 사용하여 배포되는 많은 서비스는 Docker Hub라는 이미지 공개 저장소에서 공유되고 있어요. 도커로 배포되는 서비스에 특별한 설명이 없을 경우, 당연히 이 곳에서 받을 수 있다고 생각해도 될 정도입니다.   누구나 도커 이미지를 배포할 수 있는 곳이기 때문에, 잘 관리되어 원활하게 동작하는 이미지를 찾는 것이 쉬운 설치의 지름길입니다.   잘 만들어진 이미지는 보통,      서비스 개발사 공식 이미지 (Official Image 태그가 붙어 있고, 이미지 이름이 ‘아이디/이미지명’ 구조가 아닌 그냥 ‘이미지명’ 으로 되어 있습니다.)   다운로드 횟수가 많은 이미지   매뉴얼이 잘 써진 이미지   정도가 되겠습니다. 사실 가장 좋은 건 남들이 깔아봤다는 이미지   자, 이제 하나 골라서 설치해 봅시다.   Docker 실행 명령 이해하기   docker run 공식 문서   도커 이미지는 보통 이미지의 실행 명령어와 같이 공유가 됩니다. 이 명령어가 어떤 의미인지를 이해하고, 각자의 상황에 맞게 바꿔주는 것이 가장 중요합니다.   일반적으로 docker run으로 시작되는 이 실행 명령어의 각 요소가 어떤 의미인지 알아봅시다. 예시로는 제가 제작한 허접한 이미지를 가져왔어요.   docker run -d \\   --name=showdown \\   -e PUID=0 \\   -e PGID=100 \\   -e PERMISSION=777 \\   -p 4080:80 \\   -p 4040:4040 \\   -p 4088:8080 \\   -p 4091:9091 \\   -p 4413:51413 \\   -p 4413:51413/udp \\   -v /path/to/transmission/downloads:/transmission \\   -v /path/to/showdown:/showdown \\   -v /path/to/showdown-manager:/showdown-manager \\   -v /path/to/output/files:/output \\   --restart unless-stopped \\   banyazavi/showdown:amd64   \\ (역슬래시, 환경에 따라 ￦ 으로 보일 수도 있습니다.) 는 터미널에서 명령이 끝나지 않았음을 의미합니다. 즉, 저 명령은 ‘'를 제거하고 한 줄로 쓴 것과 동일해요. 근데 그건 너무 길잖아요. 그래서 보통 저렇게 나누어 씁니다.   docker run   docker run은 컨테이너 만들어 실행한다는 의미입니다.   -d   -d는 이 컨테이너를 백그라운드로 실행한다는 의미에요. 이 옵션이 생략된다면 명령 실행 시 로그가 화면에 출력되며, 터미널 종료 시 컨테이너도 종료하게 됩니다.   여기까지는 OMV 도커 플러그인에서 신경쓸 필요가 없는 부분입니다. 플러그인에서는 docker run -d까지를 당연히 사용하는 것으로 간주하거든요. 하지만 이 다음부터는 상황에 따라 바꿔줘야 할 일이 굉장히 많아집니다.   –name=CONTAINTER_NAME   이 부분은 컨테이너 각각을 인식하는 이름을 지어주는 부분입니다. 같은 이미지에 대한 컨테이너를 여러 개 만들 수도 있으므로, 이를 구분해 주기 위해 사용합니다.   이 부분을 생략하면 임의의 이름으로 컨테이너가 생성되게 됩니다.      [NOTE]     도커가 임의로 컨테이너 이름을 붙이는 규칙은 형용사_과학자 이름 구조입니다. 컨테이너 이름을 보고 어떤 사람을 의미하는 것인지 추측해보세요. 전 mad_einstein 나옴    -e KEY=VALUE   -e는 환경 변수를 지정하는 옵션입니다. 컨테이너 실행 시 상황에 따라 설정값을 바꿔줘야 하는 경우가 있는데, 그 값을 컨테이너 내부에 전달해 주는 옵션이에요.   예시처럼 -e PUID=0 이라고 적혀 있다면, PUID라는 내부 옵션을 0으로 설정한다는 뜻입니다.   이 옵션이 무슨 의미인지, 무슨 값을 사용할 수 있는지는 이미지마다 달라요. 해당 도커 이미지의 매뉴얼을 확인하세요.   -p LOCAL_PORT:CONTAINER_PORT   -p는 이 컨테이너에서 사용하는 포트를 컨테이너 바깥 (= 우리가 접속할 수 있는 곳) 과 연결해 줄 수 있는 포트 매핑 옵션입니다. 어렵게 생각할 것 없이, 컨테이너를 공유기로 가정하고, 그 안팎으로 포드포워딩을 해준다고 생각하면 됩니다.   따라서 -p 4080:80은 컨테이너 내부에서 사용하는 80번 포트를 컨테이너 밖에서는 4080번으로 생각하고 접근한다는 의미입니다.   보통 80번 포트는 웹 서버가 사용하는 포트이므로, 컨테이너 설치 후 웹 브라우저를 열어 나스_주소:4080으로 접속하면 서비스에 관련한 뭔가가 뜰 것을 기대할 수 있죠.   : 왼쪽의 로컬 포트는 나스에서 현재 사용중인 포트와 겹치면 안 되므로, 이미 사용중인 서비스의 포트를 고려하여 겹치지 않는 번호를 할당합니다. 일반적으로 HTTP 공식 포트인 80, HTTPS의 443이 잘 겹치고, 이 포트에서 파생된 8080, 8000 등도 자주 겹치는 편이에요.   -v /local/path:/container/path   -v는 볼륨 바인딩이라고 하여, 컨테이너 내부의 특정 경로를 나스의 특정 경로와 이어 주는 역할을 합니다. 일종의 공유 폴더와 같은 셈이죠. 또한 폴더 뿐만 아니라 파일도 연결할 수 있습니다.   이에 따라서 예시의 -v /path/to/transmission/downloads:/transmission 부분을 해석하면, 컨테이너 내부에 /transmission이라는 폴더가 있는데, 이를 나스의 /path/to/transmission/downloads 폴더와 연결시킨다는 뜻입니다. 물론 /path/to/transmission/downloads라는 폴더가 있을 리 없으니, 그 부분을 이 목적에 사용될 폴더의 경로로 바꿔줘야 겠죠.   주의할 것은, 반드시 /으로 시작되는 절대 경로로 적어야 한다는 점입니다. 목적 폴더에 접속한 뒤 pwd 명령을 실행하여 절대 경로를 확인할 수 있습니다.   –restart restart_policy   도커는 가상 머신과는 다르게, 컨테이너에서 실행하는 내용이 끝나면 컨테이너를 멈추게 됩니다. --restart는 이 때 컨테이너를 어떻게 재시작할지 정책에 대한 설정입니다. 네 종류가 있어요.      no: 재시작하지 않습니다.   always: 항상 재시작합니다.   unless-stopped: 종료되지 않는 한 항상 재시작합니다.   on-failure: 컨테이너가 오류로 꺼졌을 때만 재시작합니다.   2번과 3번이 차이가 없어 보일 수 있는데, 두 옵션의 차이는 컨테이너가 중단된 후 도커 (또는 나스째로) 가 재부팅 되었을 때 차이가 있습니다. always는 무조건 다시 켜지지만, unless-stopped는 도커가 중단된 후 나스가 재부팅 되었을 때는 다시 켜지지 않아요.   user/image[:tag]   banyazavi/showdown:amd64으로 표현되어 있는 마지막 부분은 이 이미지의 정보입니다.   tag는 생략 가능한 옵션으로, 생략하면 latest 태그를 찾아 실행시키게 됩니다. 버전이나 실행 환경의 차이에 따라 이미지를 나누어둔 경우가 있으므로, latest를 사용해도 되는지, 자신에게 맞는 태그가 있는지 확인할 필요가 있어요.   OMV4에서 도커 컨테이너 실행하기 - Nextcloud 설치   물론 우리는 저 내용을 터미널에 입력할 필요는 없습니다. 서비스 &gt; Docker 페이지에서 같은 작업을 수행할 수 있거든요.   실행 명령 확인   그 시범으로 Nextcloud라는 설치형 클라우드를 가져왔습니다. 그리고 Docker Hub - Nextcloud의 매뉴얼과 인터넷의 수많은 팁을 통해 아래와 같은 docker run 명령으로 서비스를 설치할 수 있다고 알게 되었습니다. 고 칩시다.   docker run -d \\   --name=omv4_nextcloud   --restart always \\   -p 6080:80 \\   -v nextcloud:/var/www/html \\   nextcloud   이 명령어 내용대로 컨테이너를 만들어 볼 겁니다.   Docker 플러그인에서 설정   우선, 뭔가 폴더를 연결시켜줘야 하는 듯 싶으니, 공유 폴더에서 nextcloud라는 폴더를 하나 만들어 둡니다.   그리고 서비스 &gt; Docker 페이지에서 복제본 당겨오기 버튼을 눌러 이미지를 가져오구요.      꼬리표 부분을 생략하면 latest 태그의 이미지를 가져오게 됩니다. 혹시 다른 tag를 가져오려면 꼬리표 에 태그를 입력해 주세요.   그리고 사용할 nextcloud 이미지를 클릭하고 복제본 실행 버튼을 눌러 아래 그림과 같이 설정합니다.      각 부분이 무엇을 의미하는지는, 윗 챕터를 열심히 읽었으면 쉽게 이해할 수 있을 거에요.   이 경우에는 환경 변수가 엄청나게 많이 나오는데요, 이것은 이미지에서 기본값으로 설정해둔 모든 환경 변수가 다 표시되는 것으로 직접 설정한 것이 아닙니다. 만약 필요하다면 여기에 환경 변수를 새롭게 추가하거나 기존 변수를 수정할 수도 있습니다.   컨테이너 실행 확인   일반적으로 80 포트가 서비스 접속 포트이고, 우리는 이것을 6080으로 설정했으니, http://나스주소:6080으로 접속해 봅시다.      잘 뜨네요. 이제 이 페이지에서 남은 설정을 완료하고 서비스를 사용하면 됩니다.      [NOTE]     지금 글의 방법으로 설치한 넥스트클라우드는 별도의 DB를 설치하지 않아 SQLite로만 설정하여 사용할 수 있습니다. 그림에서 경고하듯 성능이 좋은 편은 아니니 실제로 사용하시려면 DB를 같이 설치하여 사용하는 것이 좋습니다.      그리고 남은 이야기   이것으로 OMV4 자작 NAS 구축하기는 끝입니다. 나머지는 기존의 글을 응용하여 직접 플러그인이나 도커 컨테이너를 설치하여 기능을 확장할 수 있을 거에요.   openmediavault는 시놀로지에 비해서는 편의성도, 기능도 완벽하지 못한 나스 솔루션이지만, 커뮤니티에서 개발하여 배포하는 무료 솔루션 중에서는 가장 직관적이고 다루기 쉬운 것이라고 생각합니다. OMV5에서 플러그인 다수를 포기하고 대부분을 외부의 도커 서비스로 대체한 것은 별로 마음에 들지 않긴 하지만… 커뮤니티 개발의 한계라고 납득은 되구요.   그나마 다행인 점은, 데비안을 기반으로 하여 돌아가기 때문에 데비안/우분투 팁을 참고하여 문제를 해결하기 좋다는 점이 아닐까요.   이 글들을 통해 성공적인 자작 나스 구축이 되셨으면 좋겠습니다. 감사합니다.  ","categories": ["OMV4 자작 NAS 구축하기"],
        "tags": ["Let's Encrypt","NAS","openmediavault","SSL","TLS"],
        "url": "http://0.0.0.0:4000/2019-12-22/Docker-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%84%A4%EC%B9%98",
        "teaser":null},{
        "title": "Docker Cookbook",
        "excerpt":"   컴퓨터 업계에서 “Cookbook”이란 어떤 것을 쉽게 설정하거나 구현할 수 있게 하는 코드 묶음을 의미합니다. 우리는 이 쿡북을 통해서 도커 서비스를 쉽게 설치해 보려고 해요.        Docker를 사용한 서비스 구성의 편리성     Docker 공식 홈페이지   지난 글에서 한번 설명을 했었죠. Docker는 컨테이너 기반의 리눅스 가상화 도구입니다.   본래 도커는 가상화 목적으로 제작된 도구이지만, 가상화가 가져다 주는 장점 (내부 환경이 제작자 의도대로 구성되어 있다.) 덕분에 홈서버에 서비스를 편리하게 설치하는 방법으로 활용되고 있죠.   그래서 이번 시리즈는 도커를 통해 배포되는 서비스를 소개하고, 이를 최소한의 이해와 수정으로 사용할 수 있도록 설치 코드 프리셋을 제공해 드리려고 해요.   자신의 아키텍처가 뭔지는 알아 둡시다   도커가 아무리 사용자 환경에 상관 없이 설치를 제공한다고는 해도, 정말 모든 곳에 동일하게 설치되는 것은 아니에요. 컴퓨터에는 아키텍처라는 것이 있는데, 기본적으로 이게 다르면 설치 환경이 달라질 수 밖에 없어요.   문제는 도커 이미지가 모든 아키텍처를 제공하지 않을 수도 있다는 건데요. 지원 여부는 Docker Hub의 경우 이미지의 태그를 확인해 보면 알 수 있죠.      LinuxServer.io에서 제공하는 Transmission 이미지의 검색 결과입니다. x86-64, arm 그리고 arm64 태그가 보이죠? 이게 바로 지원하는 아키텍처에요.   도커는 원래 x86 대상의 도구였기 때문에, x86 기반의 데스크탑 서버는 (CPU가 Intel이나 AMD라면) 도커허브에 있는 대부분의 이미지를 사용할 수 있습니다. 그러나 그렇지 않은 경우라면 (라즈베리파이와 같은 대부분의 SBC의 경우) 해당 아키텍처를 지원하는 이미지인지 확인을 해 보셔야 합니다.   저는 arm 아키텍처인 오드로이드 XU4와 x86-64 아키텍처인 홈서버 (오드로이드 H2) 두 가지로 테스트하고 글을 쓸 거에요. 따라서 두 아키텍처의 설치 코드가 차이가 발생하거나, arm 아키텍처에서 설치할 수 없을 경우에는 이를 따로 알려주고 글을 시작하도록 하겠습니다.   하지만 유명한 서비스들 위주로 소개를 할 것이기 때문에, 대부분은 둘 다 무리 없이 동작할 거에요.   Docker Compose를 ‘알아만’ 둡시다     Docker Compose 소개 문서   Docker Compose는 여러 개의 컨테이너로 구성된 도커 어플리케이션을 정의할 수 있게 하는 도구입니다. docker-compose.yml이라고 하는 YAML 서식의 파일에 구성을 기록하고, docker-compose up이라는 명령어를 통해 해당 구성으로 도커 컨테이너를 실행할 수 있게 합니다. 이해가 잘 안되죠?   우리는 이걸 그냥 도커 설정을 더 정교하게 할 수 있는 도구라고만 생각합시다. 앞으로 제공할 코드가 각 서비스에 대한 docker-compose.yml 구성 프리셋이라서, 그냥 그렇다는 걸 알려만 드리는 거에요.   심지어 우리는 docker-compose.yml 파일을 만들고 docker-compose up 같은 명령어를 콘솔에 칠 생각도 없습니다. Portainer를 설치해서 웹으로 관리할 거에요.   Portainer     Portainer 공식 홈페이지   Portainer는 도커 관리 웹 패널입니다. 기능이 꽤 강력해서 원격지의 도커를 관리한다거나 할 수도 있긴 한데요, 우리는 그냥 도커가 깔린 서버에 같이 깔아서 local로만 사용할 겁니다.   포테이너에는 Stack이라고 하는 관리 메뉴가 있는데요. 여러 개의 컨테이너로 구성된 도커 어플리케이션을 코드를 통해 관리하는 방법이에요. 즉, 도커컴포즈를 사용한다는 의미입니다.   그래서 우리는 도커와 포테이너 설치까지만 명령어로 설치하고, 나머지는 포테이너를 통해서 웹으로 작업할 거에요. 물론, 서비스가 설치될 폴더를 만들어둔다거나 하는 부분은 콘솔이나, 적어도 FTP나 SMB와 같은 방법으로 하셔야 합니다. 하지만 이정도는 별로 어렵지 않죠.     앞으로 할 내용들   첫 시간은 서버에 도커와 포테이너를 설치하고, Add stack 버튼을 눌러보는 단계까지 진행할 거에요.   그리고 그 이후에는 재미있어 보이는 순서대로 홈서버에서 실행할 만한 서비스를 설치해 볼 겁니다.  ","categories": ["Docker Cookbook"],
        "tags": ["Docker"],
        "url": "http://0.0.0.0:4000/2020-02-20/Docker-Cookbook",
        "teaser":null},{
        "title": "Docker와 Portainer 설치",
        "excerpt":"   이 시리즈를 위한 가장 기본적인 도구 두 개를 먼저 설치해야 합니다.        Docker와 Portainer   굉장히 여러번 말씀드리는 것 같지만, Docker는 컨테이너 기반의 리눅스 가상화 도구입니다. 그러나 우리는 홈서버에 서비스를 편리하게 설치하기 위한 일종의 플랫폼으로 생각하자고 했죠.   그리고 Portainer는 도커를 웹으로 편하게 관리하기 위한 도구입니다. SSH에 접속하여 코드를 칠 필요 없이, 포테이너 웹페이지에서 마우스 클릭으로 운영할 수 있다는 것이죠.   그래서 이 두개를 이 시리즈의 핵심 기반으로 두고, 이 도구들을 설치하는 것을 첫 번째 목표로 하였습니다.   Docker 설치   도커는 대부분의 리눅스 시스템에 설치할 수 있습니다. Ubuntu나 Debian, CentOS 등은 각자의 패키지 관리 툴을 이용한 설치 방법도 제공하고 있구요. 바이너리를 직접 다운받아 설치할 수도 있습니다. 시놀로지는 터미널에 접속할 필요 없이 웹 패널의 패키지 센터에서 설치할 수 있습니다. 각자 편한 방법으로 설치하면 됩니다.   따라서 아래의 설치 명령어는 우분투를 기준으로 작성했어요. 다른 배포판의 설치 스크립트는 여기에서 확인할 수 있습니다. Docker 공식 Install 문서 (Docker Engine &gt; Linux &gt; 배포판 선택하여 볼 수 있어요.)   도커가 아무리 사용자 환경에 상관 없이 설치를 제공한다고는 해도, 정말 모든 곳에 동일하게 설치되는 것은 아니에요. 컴퓨터에는 아키텍처라는 것이 있는데, 기본적으로 이게 다르면 설치 환경이 달라질 수 밖에 없어요.   오래된 Docker 제거   이미 도커가 설치되어 있는 경우에, 오래된 도커 버전을 제거합니다. 도커가 설치되어 있지 않은 경우에는 실행이 무시되므로 일단 실행시키면 됩니다.   $ sudo apt-get remove docker docker-engine docker.io containerd runc   패키지 업데이트   일단 패키지 업데이트를 한번 해 줍니다. 가능하면 최신 버전을 깔아야 하니까요.   $ sudo apt-get update   관련 패키지 설치   도커 저장소 설정을 위해 HTTPS 사용을 할 수 있게 하는 패키지들을 설치합니다.   $ sudo apt-get install -y \\     apt-transport-https \\     ca-certificates \\     curl \\     gnupg-agent \\     software-properties-common   Docker GPG Key 추가   도커 패키지의 인증을 위한 GPG Key를 추가해줍니다.   $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -   Docker 저장소 추가   이건 아키텍처별로 다른데요, 아래 명령어의 [arch=amd64] 부분에 자신의 홈서버 아키텍처를 넣어주면 됩니다.   $ sudo add-apt-repository \\    \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\    $(lsb_release -cs) \\    stable\"   배포판별로 지원되는 아키텍처가 다르므로 공식 문서 페이지에서 확인해보는 것이 좋겠네요. 일반적으로는 아래와 같은 아키텍처 선택이 가능합니다.      [arch=amd64]   [arch=armhf]   [arch=arm64]   그리고 다시 패키지 업데이트   원래는 저장소 추가하면서 패키지 업데이트를 한번 해 줄텐데, 혹시 모르니 한번 더 해 줍시다.   $ sudo apt-get update   Docker 패키지 설치   이제 아래 명령어만 입력하면 도커의 설치가 완료됩니다!   $ sudo apt-get install -y docker-ce docker-ce-cli containerd.io   설치 확인   제대로 설치되었는지 확인해 봅시다. 일단 버전부터 확인해 볼까요?   $sudo docker --version  Docker version 19.03.6, build 369ce74   작성일 기준으로 19.03.6 버전이 최신인 것 같네요.   $ sudo docker ps -a  CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES   생성되어 있는 모든 컨테이너를 조회하는 명령입니다. 아무 것도 만들지 않았으니 당연히 없겠죠. 설치 오류 등으로 서비스가 제대로 실행되어 있지 않다면 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 이런 메시지가 나올 거에요.   이렇게 도커 설치는 완료되었습니다. 이제 포테이너를 설치해 봅시다.   Portainer 설치   포테이너는 도커 서비스입니다. 도커 관련된 서비스라는 것도 맞는데, 이 서비스 자체도 도커 컨테이너로 실행 시키거든요! 그래서 명령어가 굉장히 간단한 편에 속하죠.   공식 설치 문서에서도 단 두줄로 안내하고 있습니다. 따라해 봅시다.   Portainer 데이터 볼륨 설정   포테이너 데이터를 담아둘 볼륨을 설정합니다.   $sudo docker volume create portainer_data   Portainer 컨테이너 생성   그리고 아래 명령어를 입력하여 포테이너 이미지를 다운받고 실행합니다.   $ sudo docker run -d \\     -p 8000:8000 \\     -p 9000:9000 \\     --name=portainer \\     --restart=always \\     -v /var/run/docker.sock:/var/run/docker.sock \\     -v portainer_data:/data \\     portainer/portainer   Portainer 초기 설정   설치가 완료되었다면 http://홈서버_IP:9000과 같이, 홈서버의 9000번 포트로 접속할 수 있습니다.      최초 접속 시 관리자 계정을 설정하는 화면이 나옵니다. 원하는 이름과 비밀번호를 설정해 주세요.      도커 관리 환경 설정 화면입니다. 우리는 포테이너가 설치된 서버에서 도커를 같이 실행시킬 것이므로, Local이에요.      그럼 이제 홈 화면이 보입니다. 여기에 보이는 local이 우리 도커의 현재 상황이에요. 자세한 설정을 위해 카드를 눌러봅시다.      좀 더 자세한 상태를 볼 수 있어요. 컨테이너가 하나 실행되고 있죠? 그건 포테이너입니다.   앞으로 가이드에 주로 쓰일 메뉴는 Stacks입니다. 눌러서 들어가봅시다.      스택 관리 화면입니다. 스택은 포테이너에서 정의하는 컨테이너 묶음인데요. 저번 글에서 잠깐 언급했지만, Docker Compose 구성들을 의미한다고 보면 됩니다. 현재는 아무것도 구성하지 않았으니 목록이 비어 있어요.   앞으로의 글은 이 화면에서 Add Stack을 누른 다음,      여기의 Web editor 아래의 공간에 들어갈 내용을 안내할 겁니다.     그리고 남은 이야기   도커를 원활하게 사용하려면 몇 가지 리눅스 명령어는 알고 있어야 해요. 아래 대표적인 명령들입니다.      ls: List Segments. 현재 폴더의 내용을 보는 명령입니다.   cd [path]: Change Directory. 폴더를 이동하는 명령입니다.   pwd: Print Working Directory. 현재 폴더의 절대 경로를 출력하는 명령입니다. 나중에 볼륨 맵핑할때 유용하게 사용하게 됩니다.   mkdir -p [path]: MaKe DIRectory. 폴더를 생성하는 명령입니다. -p 옵션을 넣으면 해당 폴더를 만들기 위해 필요한 상위폴더까지 자동으로 만들게 돼요.   이 정도만 알고 있으면, 나머지는 포테이너에서 거의 다 할 수 있을 거에요.  ","categories": ["Docker Cookbook"],
        "tags": ["Docker","Portainer"],
        "url": "http://0.0.0.0:4000/2020-02-23/Docker%EC%99%80-Portainer-%EC%84%A4%EC%B9%98",
        "teaser":null},{
        "title": "Nginx Proxy Manager 설치",
        "excerpt":"   대부분의 서비스를 웹 페이지를 통해 접속할 거에요. 그러면 HTTPS 설정 서비스부터 설치하는 것이 좋겠죠?         [NOTE]     이 서비스는 x86-64와 arm 아키텍처의 설치 방법에 차이가 있습니다.      Nginx Proxy Manager     Nginx Proxy Manager 공식 홈페이지   역방향 프록시 개념은 OMV4 나스 구축 가이드의 Nginx 역방향 프록시 설정에서 한번 다룬 내용입니다. 역방향 프록시를 사용하게 되면 여러분의 홈서버에 HTTPS 적용을 쉽게 할 수 있어요.   또한 이 서비스는 Let’s Encrypt SSL/TLS 인증서 적용도 쉽게 할 수 있습니다.   그리고 이 서비스가 저와 같은 OMV 사용자에게 중요해진 이유가 있습니다. OMV5부터는 Nginx와 Let’s Encrypt 플러그인이 삭제 되었거든요. 따라서 편하게 설치하려면 이러한 서비스가 필요합니다.   자 그럼, 엔진엑스 프록시 매니저를 도커로 설치해봅시다. 이 글은 해당 서비스의 설치 가이드를 한국어로 쉽게 풀어 설명한 것에 가까우니, 해당 링크를 참조하셔도 좋습니다.   사전 작업   다른 서비스들은 사전 작업으로 볼륨 매핑할 폴더를 만들어두거나, 기껏해야 설정 파일을 미리 구성하는 정도 밖에 없는데요. 이 서비스는 홈서버의 웹 접속을 총괄하는 역할을 가지고 있기 때문에 포트포워딩도 해 줘야 합니다. 도메인 연결도 이 참에 해 둬야겠네요.   도메인 연결 (DNS or DDNS)   Duck DNS와 같은 DDNS 서비스나, 도메인을 구입하여 홈서버에 연결을 시켜주세요.   Duck DNS를 사용하실 경우에는 IP 갱신 스크립트 설치를 참고하여 설정하시거나, DuckDNS DDNS 설치하는 OMV 가이드를 보셔도 좋습니다.   DNS를 연결하실 때는 네임서버에 *.yourdomain.com과 같은 방식으로 서브도메인 전체를 홈서버에 연결해 주셔야 합니다. 아니면 프록시 매니저에서 설정한 각각의 서브도메인에 대한 네임서버 연결을 모두 홈서버로 지정해 주셔도 됩니다. 다만 그건 좀 귀찮겠죠.   공유기 포트포워딩 설정   공유기에 80 (HTTP), 443 (HTTPS) 포트에 대한 포트포워딩을 해 줍시다. 인터넷 서비스 제공자가 80/443 같은 기본 포트를 막아두었거나, 다른 포트를 사용하시려면 포트포워딩 규칙을 바꾼 후에 컨테이너 배포 시 서비스 설정도 바꿔주시면 됩니다.   아, 그리고 80 포트는 기존 홈서버에 설치되어 있는 서비스가 이미 사용하고 있을 확률이 높습니다. 저는 기존 서비스의 포트를 바꾸는 것을 추천하는 편이에요. 그만큼 이 서비스는 HTTP/HTTPS 접속의 기본이 되는 서비스에요.      HTTP는 이렇게, 내부 IP주소는 당연히 홈서버의 IP이구요.      HTTPS 또한 포트만 바꿔서 동일한 방식으로 설정해 줍니다.   맵핑 폴더 생성   서비스에 필요한 파일을 저장할 폴더를 만들 거에요. 이 시리즈에서 저는 특이사항이 없다면 일관적으로 루트 폴더 아래 /docker/서비스명/과 같은 서비스에 대한 폴더를 만들고, 그 아래에 추가적으로 관련 폴더를 넣을 생각입니다.   만약에 여러분의 홈서버가 루트 폴더 아래에 폴더를 만들면 안 되는 경우 다른 폴더를 지정할 수 있습니다.   시놀로지와 OMV는 아래와 같은 사유로 다른 위치에 맵핑 폴더를 만드셔야 할 거에요.      시놀로지: 루트 바로 아래 쓰기가 금지되어 있어 /volmue1/ 과 같은 디스크 마운트 위치 아래에 만들어야 합니다.   OMV: 루트 볼륨의 용량이 부족한 경우가 대부분이라 /srv/dev-disk-by-label-SOMETHING/ 과 같은 디스크 마운트 절대경로 아래에 만드시는 게 좋아요.   폴더 경로를 바꾸어 생성하실 때는 아래 내용을 그대로 복붙해서 진행하시면 안되고, 관련 경로를 수정해서 적용하셔야 합니다.   서비스 기본 폴더 생성   아까 /docker/서비스명/과 같은 규칙으로 서비스 기본 폴더를 만든다고 했었죠? 따라서 아래와 같은 명령을 입력하면 됩니다. 다른 경로로 기본 폴더를 만드실 경우에는 이 경로가 보이는 족족 바꿔주신 경로로 치환해주시면 됩니다.   $ mkdir -p /docker/nginx-proxy-manager   Data 폴더 생성   서비스 데이터를 보관하고 있는 위치에요. 사실 대부분의 폴더 생성 부분은 도커 이미지 제작자가 만들라는 대로 만드는 거라서 정확히 어떻게 쓰이는 지 알고 하는 편은 아닙니다.   $ mkdir -p /docker/nginx-proxy-manager/data   DB 폴더 생성   data 폴더 아래에 MySQL (MariaDB) DB를 저장할 폴더도 만들 거에요.   $ mkdir -p /docker/nginx-proxy-manager/data/mysql   Let’s Encrypt 폴더 생성   Let’s Encrypt의 인증 정보를 담은 폴더도 생성합니다. 여기에 있는 인증서를 다른 서비스에서도 활용할 수 있어 보이는데요. 시도해봤는데 이 폴더 안에선 인증서 이름이 숫자로 관리되고 있어 쉽지 않더라구요.   $ mkdir -p /docker/nginx-proxy-manager/letsencrypt   DB 설정파일 생성   이 서비스는 DB 설정파일도 만들어 넣어주어야 합니다.   기본 경로 아래 config.json 파일을 만들어서 아래와 같은 내용을 적어줍니다. 아래와 같이 nano 에디터로 파일을 열어서, (또는 vi 에디터를 쓰시거나)   $ nano /docker/nginx-proxy-manager/config.json   아래 내용을 복붙하시고,   {   \"database\": {     \"engine\": \"mysql\",     \"host\": \"db\",     \"name\": \"npm\",     \"user\": \"npm\",     \"password\": \"npm\",     \"port\": 3306   } }   Ctrl + O 누르고 엔터 쳐서 저장하시면 돼요.   그런데 이것도 어렵고 귀찮죠? 그래서 이 블로그에서 직접 받을 수도 있게 했습니다. 이 사이트가 없어지지 않는 이상 아래 명령어로 설정 파일을 받을 수 있을 거에요.   $  wget -O /docker/nginx-proxy-manager/config.json https://blog.banyazavi.com/assets/files/2020-03-01/config.json   도커 컨테이너 생성   여기까지 잘 따라하셨다면, 아래의 docker-compose 파일 내용을 포테이너의 Add Stack &gt; Web editor 아래의 공간에 복사하여 붙여 넣습니다.   --- version: \"2\" services:   app:     image: jc21/nginx-proxy-manager:2     restart: always     ports:       # Public HTTP Port:       - 80:80       # Public HTTPS Port:       - 443:443       # Admin Web Port:       - 81:81     volumes:       # Make sure this config.json file exists as per instructions above:       - /docker/nginx-proxy-manager/config.json:/app/config/production.json       - /docker/nginx-proxy-manager/data:/data       - /docker/nginx-proxy-manager/letsencrypt:/etc/letsencrypt     depends_on:       - db   db:     image: mariadb:latest     restart: always     environment:       MYSQL_ROOT_PASSWORD: \"npm\"       MYSQL_DATABASE: \"npm\"       MYSQL_USER: \"npm\"       MYSQL_PASSWORD: \"npm\"     volumes:       - /docker/nginx-proxy-manager/data/mysql:/var/lib/mysql   그런데 arm 아키텍처에서는 이 구성으로 실행할 수가 없습니다. 제작자가 NPM 자체는 arm을 지원하도록 만들긴 했는데요, MariaDB의 공식 이미지가 arm 지원을 하지 않거든요. 그래서 arm 아키텍처는 DB 이미지를 webhippie/mariadb로 바꿔서 생성합니다. 이에 따라 환경 변수도 차이가 나요.   --- version: \"2\" services:   app:     image: jc21/nginx-proxy-manager:2     restart: always     ports:       # Public HTTP Port:       - 80:80       # Public HTTPS Port:       - 443:443       # Admin Web Port:       - 81:81     volumes:       # Make sure this config.json file exists as per instructions above:       - /docker/nginx-proxy-manager/config.json:/app/config/production.json       - /docker/nginx-proxy-manager/data:/data       - /docker/nginx-proxy-manager/letsencrypt:/etc/letsencrypt     depends_on:       - db   db:     image: webhippie/mariadb:latest     restart: always     environment:       MARIADB_ROOT_PASSWORD: \"npm\"       MARIADB_DATABASE: \"npm\"       MARIADB_USERNAME: \"npm\"       MARIADB_PASSWORD: \"npm\"     volumes:       - /docker/nginx-proxy-manager/data/mysql:/var/lib/mysql   그리고 Deploy the stack 버튼을 눌러주세요.   서비스 동작 확인   도커 컴포즈 코드에서 알아채신 분도 있으실 거에요. NPM 서비스는 81번 포트로 접속할 수 있습니다. http://홈서버_IP:81로 접속하면 아래와 같은 화면이 나올 거에요.      초기 로그인 정보는 아래와 같습니다. 아래 정보로 최초 접속하게 되면 바로 새로운 이메일과 비밀번호를 설정하셔야 할 거에요.      Email:    admin@example.com   Password: changeme     그리고 남은 이야기   이 서비스는 다른 글에서도 종종 등장할 거에요. 외부에 노출시켜서 여러 사람들과 사용해야 하는 Wordpress와 같은 웹 사이트 서비스나 Nextcloud와 같은 설치형 클라우드가 대표적이겠네요.  ","categories": ["Docker Cookbook"],
        "tags": ["Docker","Nginx Proxy Manager","역방향 프록시"],
        "url": "http://0.0.0.0:4000/2020-03-01/Nginx-Proxy-Manager-%EC%84%A4%EC%B9%98",
        "teaser":null}]
