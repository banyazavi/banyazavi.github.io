<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2020-03-01T02:22:32+09:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">반야자비의 웹로그 저장소</title><subtitle>알게 된 것, 알아가고 있는 것 그리고 알리고 싶은 것을 기록합니다.</subtitle><author><name>반야자비</name></author><entry><title type="html">Nginx Proxy Manager 설치</title><link href="http://0.0.0.0:4000/2020-03-01/Nginx-Proxy-Manager-%EC%84%A4%EC%B9%98" rel="alternate" type="text/html" title="Nginx Proxy Manager 설치" /><published>2020-03-01T00:00:00+09:00</published><updated>2020-03-01T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2020-03-01/Nginx%20Proxy%20Manager%20%EC%84%A4%EC%B9%98</id><content type="html" xml:base="http://0.0.0.0:4000/2020-03-01/Nginx-Proxy-Manager-%EC%84%A4%EC%B9%98">&lt;blockquote&gt;
  &lt;p&gt;대부분의 서비스를 웹 페이지를 통해 접속할 거에요. 그러면 HTTPS 설정 서비스부터 설치하는 것이 좋겠죠?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;[NOTE]&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;이 서비스는 &lt;strong&gt;x86-64&lt;/strong&gt;와 &lt;strong&gt;arm&lt;/strong&gt; 아키텍처의 설치 방법에 차이가 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;nginx-proxy-manager&quot;&gt;Nginx Proxy Manager&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-03-01/2020-03-01-01-01.png&quot; alt=&quot;Nginx Proxy Manager 로고&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://nginxproxymanager.jc21.com&quot; target=&quot;_blank&quot;&gt;Nginx Proxy Manager 공식 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;역방향 프록시 개념은 OMV4 나스 구축 가이드의 &lt;a href=&quot;/2019-12-01/Nginx-역방향-프록시-설정&quot;&gt;&lt;strong&gt;Nginx 역방향 프록시 설정&lt;/strong&gt;&lt;/a&gt;에서 한번 다룬 내용입니다. 역방향 프록시를 사용하게 되면 여러분의 홈서버에 &lt;strong&gt;HTTPS&lt;/strong&gt; 적용을 쉽게 할 수 있어요.&lt;/p&gt;

&lt;p&gt;또한 이 서비스는 &lt;a href=&quot;/2019-12-14/Let's-Encrypt-SSL-TLS-인증서-적용&quot;&gt;&lt;strong&gt;Let’s Encrypt SSL/TLS 인증서 적용&lt;/strong&gt;&lt;/a&gt;도 쉽게 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 이 서비스가 저와 같은 OMV 사용자에게 중요해진 이유가 있습니다. OMV5부터는 Nginx와 Let’s Encrypt 플러그인이 삭제 되었거든요. 따라서 편하게 설치하려면 이러한 서비스가 필요합니다.&lt;/p&gt;

&lt;p&gt;자 그럼, 엔진엑스 프록시 매니저를 도커로 설치해봅시다. 이 글은 해당 서비스의 &lt;a href=&quot;https://github.com/jc21/nginx-proxy-manager/blob/master/doc/INSTALL.md?utm_source=npm-site&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;설치 가이드&lt;/strong&gt;&lt;/a&gt;를 한국어로 쉽게 풀어 설명한 것에 가까우니, 해당 링크를 참조하셔도 좋습니다.&lt;/p&gt;

&lt;h1 id=&quot;사전-작업&quot;&gt;사전 작업&lt;/h1&gt;

&lt;p&gt;다른 서비스들은 사전 작업으로 볼륨 매핑할 폴더를 만들어두거나, 기껏해야 설정 파일을 미리 구성하는 정도 밖에 없는데요. 이 서비스는 홈서버의 웹 접속을 총괄하는 역할을 가지고 있기 때문에 포트포워딩도 해 줘야 합니다. 도메인 연결도 이 참에 해 둬야겠네요.&lt;/p&gt;

&lt;h2 id=&quot;도메인-연결-dns-or-ddns&quot;&gt;도메인 연결 (DNS or DDNS)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.duckdns.org&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Duck DNS&lt;/strong&gt;&lt;/a&gt;와 같은 DDNS 서비스나, 도메인을 구입하여 홈서버에 연결을 시켜주세요.&lt;/p&gt;

&lt;p&gt;Duck DNS를 사용하실 경우에는 &lt;a href=&quot;https://www.duckdns.org/install.jsp&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;IP 갱신 스크립트 설치&lt;/strong&gt;&lt;/a&gt;를 참고하여 설정하시거나, &lt;a href=&quot;/2019-11-10/DuckDNS-DDNS-설치&quot;&gt;&lt;strong&gt;DuckDNS DDNS 설치&lt;/strong&gt;&lt;/a&gt;하는 OMV 가이드를 보셔도 좋습니다.&lt;/p&gt;

&lt;p&gt;DNS를 연결하실 때는 네임서버에 &lt;strong&gt;*.yourdomain.com&lt;/strong&gt;과 같은 방식으로 서브도메인 전체를 홈서버에 연결해 주셔야 합니다. 아니면 프록시 매니저에서 설정한 각각의 서브도메인에 대한 네임서버 연결을 모두 홈서버로 지정해 주셔도 됩니다. 다만 그건 좀 귀찮겠죠.&lt;/p&gt;

&lt;h2 id=&quot;공유기-포트포워딩-설정&quot;&gt;공유기 포트포워딩 설정&lt;/h2&gt;

&lt;p&gt;공유기에 &lt;strong&gt;80 (HTTP)&lt;/strong&gt;, &lt;strong&gt;443 (HTTPS)&lt;/strong&gt; 포트에 대한 포트포워딩을 해 줍시다. 인터넷 서비스 제공자가 80/443 같은 기본 포트를 막아두었거나, 다른 포트를 사용하시려면 포트포워딩 규칙을 바꾼 후에 컨테이너 배포 시 서비스 설정도 바꿔주시면 됩니다.&lt;/p&gt;

&lt;p&gt;아, 그리고 80 포트는 기존 홈서버에 설치되어 있는 서비스가 이미 사용하고 있을 확률이 높습니다. 저는 기존 서비스의 포트를 바꾸는 것을 추천하는 편이에요. 그만큼 이 서비스는 HTTP/HTTPS 접속의 기본이 되는 서비스에요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-03-01/2020-03-01-01-02.png&quot; alt=&quot;HTTP 포트포워딩 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTP는 이렇게, 내부 IP주소는 당연히 홈서버의 IP이구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-03-01/2020-03-01-01-03.png&quot; alt=&quot;HTTPS 포트포워딩 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTPS 또한 포트만 바꿔서 동일한 방식으로 설정해 줍니다.&lt;/p&gt;

&lt;h2 id=&quot;맵핑-폴더-생성&quot;&gt;맵핑 폴더 생성&lt;/h2&gt;

&lt;p&gt;서비스에 필요한 파일을 저장할 폴더를 만들 거에요. 이 시리즈에서 저는 특이사항이 없다면 일관적으로 루트 폴더 아래 &lt;code class=&quot;highlighter-rouge&quot;&gt;/docker/서비스명/&lt;/code&gt;과 같은 서비스에 대한 폴더를 만들고, 그 아래에 추가적으로 관련 폴더를 넣을 생각입니다.&lt;/p&gt;

&lt;p&gt;만약에 여러분의 홈서버가 루트 폴더 아래에 폴더를 만들면 안 되는 경우 다른 폴더를 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;시놀로지와 OMV는 아래와 같은 사유로 다른 위치에 맵핑 폴더를 만드셔야 할 거에요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;시놀로지&lt;/strong&gt;: 루트 바로 아래 쓰기가 금지되어 있어 &lt;code class=&quot;highlighter-rouge&quot;&gt;/volmue1/&lt;/code&gt; 과 같은 디스크 마운트 위치 아래에 만들어야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OMV&lt;/strong&gt;: 루트 볼륨의 용량이 부족한 경우가 대부분이라 &lt;code class=&quot;highlighter-rouge&quot;&gt;/srv/dev-disk-by-label-SOMETHING/&lt;/code&gt; 과 같은 디스크 마운트 절대경로 아래에 만드시는 게 좋아요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;폴더 경로를 바꾸어 생성하실 때는 아래 내용을 그대로 복붙해서 진행하시면 안되고, 관련 경로를 수정해서 적용하셔야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;서비스-기본-폴더-생성&quot;&gt;서비스 기본 폴더 생성&lt;/h3&gt;

&lt;p&gt;아까 &lt;code class=&quot;highlighter-rouge&quot;&gt;/docker/서비스명/&lt;/code&gt;과 같은 규칙으로 서비스 기본 폴더를 만든다고 했었죠? 따라서 아래와 같은 명령을 입력하면 됩니다. 다른 경로로 기본 폴더를 만드실 경우에는 이 경로가 보이는 족족 바꿔주신 경로로 치환해주시면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir -p /docker/nginx-proxy-manager
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;data-폴더-생성&quot;&gt;Data 폴더 생성&lt;/h3&gt;

&lt;p&gt;서비스 데이터를 보관하고 있는 위치에요. 사실 대부분의 폴더 생성 부분은 도커 이미지 제작자가 만들라는 대로 만드는 거라서 정확히 어떻게 쓰이는 지 알고 하는 편은 아닙니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir -p /docker/nginx-proxy-manager/data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;db-폴더-생성&quot;&gt;DB 폴더 생성&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 폴더 아래에 &lt;strong&gt;MySQL (MariaDB) DB&lt;/strong&gt;를 저장할 폴더도 만들 거에요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir -p /docker/nginx-proxy-manager/data/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;lets-encrypt-폴더-생성&quot;&gt;Let’s Encrypt 폴더 생성&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Let’s Encrypt&lt;/strong&gt;의 인증 정보를 담은 폴더도 생성합니다. 여기에 있는 인증서를 다른 서비스에서도 활용할 수 있어 보이는데요. 시도해봤는데 이 폴더 안에선 인증서 이름이 숫자로 관리되고 있어 쉽지 않더라구요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir -p /docker/nginx-proxy-manager/letsencrypt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;db-설정파일-생성&quot;&gt;DB 설정파일 생성&lt;/h2&gt;

&lt;p&gt;이 서비스는 DB 설정파일도 만들어 넣어주어야 합니다.&lt;/p&gt;

&lt;p&gt;기본 경로 아래 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.json&lt;/code&gt; 파일을 만들어서 아래와 같은 내용을 적어줍니다. 아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;nano&lt;/code&gt; 에디터로 파일을 열어서, (또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;vi&lt;/code&gt; 에디터를 쓰시거나)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nano /docker/nginx-proxy-manager/config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 내용을 복붙하시고,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;database&quot;: {
    &quot;engine&quot;: &quot;mysql&quot;,
    &quot;host&quot;: &quot;db&quot;,
    &quot;name&quot;: &quot;npm&quot;,
    &quot;user&quot;: &quot;npm&quot;,
    &quot;password&quot;: &quot;npm&quot;,
    &quot;port&quot;: 3306
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Ctrl + O&lt;/strong&gt; 누르고 &lt;strong&gt;엔터&lt;/strong&gt; 쳐서 저장하시면 돼요.&lt;/p&gt;

&lt;p&gt;그런데 이것도 어렵고 귀찮죠? 그래서 이 블로그에서 직접 받을 수도 있게 했습니다. 이 사이트가 없어지지 않는 이상 아래 명령어로 설정 파일을 받을 수 있을 거에요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$  wget -O /docker/nginx-proxy-manager/config.json https://blog.banyazavi.com/assets/files/2020-03-01/config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;도커-컨테이너-생성&quot;&gt;도커 컨테이너 생성&lt;/h1&gt;

&lt;p&gt;여기까지 잘 따라하셨다면, 아래의 &lt;strong&gt;docker-compose&lt;/strong&gt; 파일 내용을 포테이너의 &lt;strong&gt;Add Stack &amp;gt; Web editor&lt;/strong&gt; 아래의 공간에 복사하여 붙여 넣습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
version: &quot;2&quot;
services:
  app:
    image: jc21/nginx-proxy-manager:2
    restart: always
    ports:
      # Public HTTP Port:
      - 80:80
      # Public HTTPS Port:
      - 443:443
      # Admin Web Port:
      - 81:81
    volumes:
      # Make sure this config.json file exists as per instructions above:
      - /docker/nginx-proxy-manager/config.json:/app/config/production.json
      - /docker/nginx-proxy-manager/data:/data
      - /docker/nginx-proxy-manager/letsencrypt:/etc/letsencrypt
    depends_on:
      - db
  db:
    image: mariadb:latest
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: &quot;npm&quot;
      MYSQL_DATABASE: &quot;npm&quot;
      MYSQL_USER: &quot;npm&quot;
      MYSQL_PASSWORD: &quot;npm&quot;
    volumes:
      - /docker/nginx-proxy-manager/data/mysql:/var/lib/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런데 &lt;strong&gt;arm&lt;/strong&gt; 아키텍처에서는 이 구성으로 실행할 수가 없습니다. 제작자가 NPM 자체는 arm을 지원하도록 만들긴 했는데요, &lt;strong&gt;MariaDB&lt;/strong&gt;의 공식 이미지가 arm 지원을 하지 않거든요. 그래서 arm 아키텍처는 DB 이미지를 &lt;strong&gt;webhippie/mariadb&lt;/strong&gt;로 바꿔서 생성합니다. 이에 따라 환경 변수도 차이가 나요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
version: &quot;2&quot;
services:
  app:
    image: jc21/nginx-proxy-manager:2
    restart: always
    ports:
      # Public HTTP Port:
      - 80:80
      # Public HTTPS Port:
      - 443:443
      # Admin Web Port:
      - 81:81
    volumes:
      # Make sure this config.json file exists as per instructions above:
      - /docker/nginx-proxy-manager/config.json:/app/config/production.json
      - /docker/nginx-proxy-manager/data:/data
      - /docker/nginx-proxy-manager/letsencrypt:/etc/letsencrypt
    depends_on:
      - db
  db:
    image: webhippie/mariadb:latest
    restart: always
    environment:
      MARIADB_ROOT_PASSWORD: &quot;npm&quot;
      MARIADB_DATABASE: &quot;npm&quot;
      MARIADB_USERNAME: &quot;npm&quot;
      MARIADB_PASSWORD: &quot;npm&quot;
    volumes:
      - /docker/nginx-proxy-manager/data/mysql:/var/lib/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 &lt;strong&gt;Deploy the stack&lt;/strong&gt; 버튼을 눌러주세요.&lt;/p&gt;

&lt;h1 id=&quot;서비스-동작-확인&quot;&gt;서비스 동작 확인&lt;/h1&gt;

&lt;p&gt;도커 컴포즈 코드에서 알아채신 분도 있으실 거에요. NPM 서비스는 81번 포트로 접속할 수 있습니다. &lt;strong&gt;http://홈서버_IP:81&lt;/strong&gt;로 접속하면 아래와 같은 화면이 나올 거에요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-03-01/2020-03-01-01-04.png&quot; alt=&quot;Nginx Proxy Manager 접속 화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;초기 로그인 정보는 아래와 같습니다. 아래 정보로 최초 접속하게 되면 바로 새로운 이메일과 비밀번호를 설정하셔야 할 거에요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Email:    admin@example.com&lt;/li&gt;
  &lt;li&gt;Password: changeme&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그리고-남은-이야기&quot;&gt;그리고 남은 이야기&lt;/h1&gt;

&lt;p&gt;이 서비스는 다른 글에서도 종종 등장할 거에요. 외부에 노출시켜서 여러 사람들과 사용해야 하는 &lt;strong&gt;Wordpress&lt;/strong&gt;와 같은 웹 사이트 서비스나 &lt;strong&gt;Nextcloud&lt;/strong&gt;와 같은 설치형 클라우드가 대표적이겠네요.&lt;/p&gt;</content><author><name>반야자비</name></author><category term="Docker" /><category term="Nginx Proxy Manager" /><category term="역방향 프록시" /><summary type="html">대부분의 서비스를 웹 페이지를 통해 접속할 거에요. 그러면 HTTPS 설정 서비스부터 설치하는 것이 좋겠죠?</summary></entry><entry><title type="html">Docker와 Portainer 설치</title><link href="http://0.0.0.0:4000/2020-02-23/Docker%EC%99%80-Portainer-%EC%84%A4%EC%B9%98" rel="alternate" type="text/html" title="Docker와 Portainer 설치" /><published>2020-02-23T00:00:00+09:00</published><updated>2020-02-23T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2020-02-23/Docker%EC%99%80%20Portainer%20%EC%84%A4%EC%B9%98</id><content type="html" xml:base="http://0.0.0.0:4000/2020-02-23/Docker%EC%99%80-Portainer-%EC%84%A4%EC%B9%98">&lt;blockquote&gt;
  &lt;p&gt;이 시리즈를 위한 가장 기본적인 도구 두 개를 먼저 설치해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;docker와-portainer&quot;&gt;Docker와 Portainer&lt;/h1&gt;

&lt;p&gt;굉장히 여러번 말씀드리는 것 같지만, &lt;strong&gt;Docker&lt;/strong&gt;는 컨테이너 기반의 리눅스 가상화 도구입니다. 그러나 우리는 홈서버에 서비스를 편리하게 설치하기 위한 일종의 플랫폼으로 생각하자고 했죠.&lt;/p&gt;

&lt;p&gt;그리고 &lt;strong&gt;Portainer&lt;/strong&gt;는 도커를 웹으로 편하게 관리하기 위한 도구입니다. SSH에 접속하여 코드를 칠 필요 없이, 포테이너 웹페이지에서 마우스 클릭으로 운영할 수 있다는 것이죠.&lt;/p&gt;

&lt;p&gt;그래서 이 두개를 이 시리즈의 핵심 기반으로 두고, 이 도구들을 설치하는 것을 첫 번째 목표로 하였습니다.&lt;/p&gt;

&lt;h1 id=&quot;docker-설치&quot;&gt;Docker 설치&lt;/h1&gt;

&lt;p&gt;도커는 대부분의 리눅스 시스템에 설치할 수 있습니다. &lt;strong&gt;Ubuntu&lt;/strong&gt;나 &lt;strong&gt;Debian&lt;/strong&gt;, &lt;strong&gt;CentOS&lt;/strong&gt; 등은 각자의 패키지 관리 툴을 이용한 설치 방법도 제공하고 있구요. 바이너리를 직접 다운받아 설치할 수도 있습니다. &lt;strong&gt;시놀로지&lt;/strong&gt;는 터미널에 접속할 필요 없이 웹 패널의 &lt;strong&gt;패키지 센터&lt;/strong&gt;에서 설치할 수 있습니다. 각자 편한 방법으로 설치하면 됩니다.&lt;/p&gt;

&lt;p&gt;따라서 아래의 설치 명령어는 &lt;strong&gt;우분투를 기준으로 작성&lt;/strong&gt;했어요. 다른 배포판의 설치 스크립트는 여기에서 확인할 수 있습니다. &lt;a href=&quot;https://docs.docker.com/install&quot; target=&quot;_blank&quot;&gt;Docker 공식 Install 문서&lt;/a&gt; (&lt;strong&gt;Docker Engine &amp;gt; Linux &amp;gt; 배포판 선택&lt;/strong&gt;하여 볼 수 있어요.)&lt;/p&gt;

&lt;p&gt;도커가 아무리 사용자 환경에 상관 없이 설치를 제공한다고는 해도, 정말 모든 곳에 동일하게 설치되는 것은 아니에요. 컴퓨터에는 아키텍처라는 것이 있는데, 기본적으로 이게 다르면 설치 환경이 달라질 수 밖에 없어요.&lt;/p&gt;

&lt;h2 id=&quot;오래된-docker-제거&quot;&gt;오래된 Docker 제거&lt;/h2&gt;

&lt;p&gt;이미 도커가 설치되어 있는 경우에, 오래된 도커 버전을 제거합니다. 도커가 설치되어 있지 않은 경우에는 실행이 무시되므로 일단 실행시키면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get remove docker docker-engine docker.io containerd runc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;패키지-업데이트&quot;&gt;패키지 업데이트&lt;/h2&gt;

&lt;p&gt;일단 패키지 업데이트를 한번 해 줍니다. 가능하면 최신 버전을 깔아야 하니까요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;관련-패키지-설치&quot;&gt;관련 패키지 설치&lt;/h2&gt;

&lt;p&gt;도커 저장소 설정을 위해 &lt;strong&gt;HTTPS&lt;/strong&gt; 사용을 할 수 있게 하는 패키지들을 설치합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;docker-gpg-key-추가&quot;&gt;Docker GPG Key 추가&lt;/h2&gt;

&lt;p&gt;도커 패키지의 인증을 위한 GPG Key를 추가해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;docker-저장소-추가&quot;&gt;Docker 저장소 추가&lt;/h2&gt;

&lt;p&gt;이건 아키텍처별로 다른데요, 아래 명령어의 &lt;code class=&quot;highlighter-rouge&quot;&gt;[arch=amd64]&lt;/code&gt; 부분에 자신의 홈서버 아키텍처를 넣어주면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo add-apt-repository \
   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배포판별로 지원되는 아키텍처가 다르므로 공식 문서 페이지에서 확인해보는 것이 좋겠네요. 일반적으로는 아래와 같은 아키텍처 선택이 가능합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[arch=amd64]&lt;/li&gt;
  &lt;li&gt;[arch=armhf]&lt;/li&gt;
  &lt;li&gt;[arch=arm64]&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그리고-다시-패키지-업데이트&quot;&gt;그리고 다시 패키지 업데이트&lt;/h2&gt;

&lt;p&gt;원래는 저장소 추가하면서 패키지 업데이트를 한번 해 줄텐데, 혹시 모르니 한번 더 해 줍시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;docker-패키지-설치&quot;&gt;Docker 패키지 설치&lt;/h2&gt;

&lt;p&gt;이제 아래 명령어만 입력하면 도커의 설치가 완료됩니다!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;설치-확인&quot;&gt;설치 확인&lt;/h2&gt;

&lt;p&gt;제대로 설치되었는지 확인해 봅시다. 일단 버전부터 확인해 볼까요?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo docker --version

Docker version 19.03.6, build 369ce74
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;작성일 기준으로 &lt;strong&gt;19.03.6&lt;/strong&gt; 버전이 최신인 것 같네요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker ps -a

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성되어 있는 모든 컨테이너를 조회하는 명령입니다. 아무 것도 만들지 않았으니 당연히 없겠죠. 설치 오류 등으로 서비스가 제대로 실행되어 있지 않다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?&lt;/code&gt; 이런 메시지가 나올 거에요.&lt;/p&gt;

&lt;p&gt;이렇게 도커 설치는 완료되었습니다. 이제 포테이너를 설치해 봅시다.&lt;/p&gt;

&lt;h1 id=&quot;portainer-설치&quot;&gt;Portainer 설치&lt;/h1&gt;

&lt;p&gt;포테이너는 도커 서비스입니다. 도커 관련된 서비스라는 것도 맞는데, 이 서비스 자체도 도커 컨테이너로 실행 시키거든요! 그래서 명령어가 굉장히 간단한 편에 속하죠.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.portainer.io/installation&quot; target=&quot;_blank&quot;&gt;공식 설치 문서&lt;/a&gt;에서도 단 두줄로 안내하고 있습니다. 따라해 봅시다.&lt;/p&gt;

&lt;h2 id=&quot;portainer-데이터-볼륨-설정&quot;&gt;Portainer 데이터 볼륨 설정&lt;/h2&gt;

&lt;p&gt;포테이너 데이터를 담아둘 볼륨을 설정합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo docker volume create portainer_data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;portainer-컨테이너-생성&quot;&gt;Portainer 컨테이너 생성&lt;/h2&gt;

&lt;p&gt;그리고 아래 명령어를 입력하여 포테이너 이미지를 다운받고 실행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker run -d \
    -p 8000:8000 \
    -p 9000:9000 \
    --name=portainer \
    --restart=always \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v portainer_data:/data \
    portainer/portainer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;portainer-초기-설정&quot;&gt;Portainer 초기 설정&lt;/h1&gt;

&lt;p&gt;설치가 완료되었다면 &lt;strong&gt;http://홈서버_IP:9000&lt;/strong&gt;과 같이, 홈서버의 9000번 포트로 접속할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-23/2020-02-23-01-01.png&quot; alt=&quot;Portainer 초기 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;최초 접속 시 관리자 계정을 설정하는 화면이 나옵니다. 원하는 이름과 비밀번호를 설정해 주세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-23/2020-02-23-01-02.png&quot; alt=&quot;Portainer 관리 환경 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 관리 환경 설정 화면입니다. 우리는 포테이너가 설치된 서버에서 도커를 같이 실행시킬 것이므로, &lt;strong&gt;Local&lt;/strong&gt;이에요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-23/2020-02-23-01-03.png&quot; alt=&quot;Portainer 홈&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이제 홈 화면이 보입니다. 여기에 보이는 &lt;strong&gt;local&lt;/strong&gt;이 우리 도커의 현재 상황이에요. 자세한 설정을 위해 카드를 눌러봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-23/2020-02-23-01-04.png&quot; alt=&quot;Portainer Docker 상태 요약&quot; /&gt;&lt;/p&gt;

&lt;p&gt;좀 더 자세한 상태를 볼 수 있어요. 컨테이너가 하나 실행되고 있죠? 그건 포테이너입니다.&lt;/p&gt;

&lt;p&gt;앞으로 가이드에 주로 쓰일 메뉴는 &lt;strong&gt;Stacks&lt;/strong&gt;입니다. 눌러서 들어가봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-23/2020-02-23-01-05.png&quot; alt=&quot;Portainer Stack 목록&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택 관리 화면입니다. 스택은 포테이너에서 정의하는 컨테이너 묶음인데요. 저번 글에서 잠깐 언급했지만, &lt;strong&gt;Docker Compose&lt;/strong&gt; 구성들을 의미한다고 보면 됩니다. 현재는 아무것도 구성하지 않았으니 목록이 비어 있어요.&lt;/p&gt;

&lt;p&gt;앞으로의 글은 이 화면에서 &lt;strong&gt;Add Stack&lt;/strong&gt;을 누른 다음,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-23/2020-02-23-01-06.png&quot; alt=&quot;Portainer Stack 생성&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기의 &lt;strong&gt;Web editor&lt;/strong&gt; 아래의 공간에 들어갈 내용을 안내할 겁니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그리고-남은-이야기&quot;&gt;그리고 남은 이야기&lt;/h1&gt;

&lt;p&gt;도커를 원활하게 사용하려면 몇 가지 리눅스 명령어는 알고 있어야 해요. 아래 대표적인 명령들입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;: &lt;strong&gt;List Segments&lt;/strong&gt;. 현재 폴더의 내용을 보는 명령입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd [path]&lt;/code&gt;: &lt;strong&gt;Change Directory&lt;/strong&gt;. 폴더를 이동하는 명령입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pwd&lt;/code&gt;: &lt;strong&gt;Print Working Directory&lt;/strong&gt;. 현재 폴더의 절대 경로를 출력하는 명령입니다. 나중에 볼륨 맵핑할때 유용하게 사용하게 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir -p [path]&lt;/code&gt;: &lt;strong&gt;MaKe DIRectory&lt;/strong&gt;. 폴더를 생성하는 명령입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt; 옵션을 넣으면 해당 폴더를 만들기 위해 필요한 상위폴더까지 자동으로 만들게 돼요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 정도만 알고 있으면, 나머지는 포테이너에서 거의 다 할 수 있을 거에요.&lt;/p&gt;</content><author><name>반야자비</name></author><category term="Docker" /><category term="Portainer" /><summary type="html">이 시리즈를 위한 가장 기본적인 도구 두 개를 먼저 설치해야 합니다.</summary></entry><entry><title type="html">Docker Cookbook</title><link href="http://0.0.0.0:4000/2020-02-20/Docker-Cookbook" rel="alternate" type="text/html" title="Docker Cookbook" /><published>2020-02-20T00:00:00+09:00</published><updated>2020-02-20T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2020-02-20/Docker%20Cookbook</id><content type="html" xml:base="http://0.0.0.0:4000/2020-02-20/Docker-Cookbook">&lt;blockquote&gt;
  &lt;p&gt;컴퓨터 업계에서 “Cookbook”이란 어떤 것을 쉽게 설정하거나 구현할 수 있게 하는 코드 묶음을 의미합니다. 우리는 이 쿡북을 통해서 도커 서비스를 쉽게 설치해 보려고 해요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;docker를-사용한-서비스-구성의-편리성&quot;&gt;Docker를 사용한 서비스 구성의 편리성&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-20/2020-02-20-01-01.png&quot; alt=&quot;Docker 로고&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.docker.com&quot; target=&quot;_blank&quot;&gt;Docker 공식 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/2019-12-22/Docker-서비스-설치&quot;&gt;지난 글&lt;/a&gt;에서 한번 설명을 했었죠. &lt;strong&gt;Docker&lt;/strong&gt;는 컨테이너 기반의 리눅스 가상화 도구입니다.&lt;/p&gt;

&lt;p&gt;본래 도커는 가상화 목적으로 제작된 도구이지만, 가상화가 가져다 주는 장점 (내부 환경이 제작자 의도대로 구성되어 있다.) 덕분에 홈서버에 서비스를 편리하게 설치하는 방법으로 활용되고 있죠.&lt;/p&gt;

&lt;p&gt;그래서 이번 시리즈는 도커를 통해 배포되는 서비스를 소개하고, 이를 최소한의 이해와 수정으로 사용할 수 있도록 설치 코드 프리셋을 제공해 드리려고 해요.&lt;/p&gt;

&lt;h1 id=&quot;자신의-아키텍처가-뭔지는-알아-둡시다&quot;&gt;자신의 아키텍처가 뭔지는 알아 둡시다&lt;/h1&gt;

&lt;p&gt;도커가 아무리 사용자 환경에 상관 없이 설치를 제공한다고는 해도, 정말 모든 곳에 동일하게 설치되는 것은 아니에요. 컴퓨터에는 아키텍처라는 것이 있는데, 기본적으로 이게 다르면 설치 환경이 달라질 수 밖에 없어요.&lt;/p&gt;

&lt;p&gt;문제는 도커 이미지가 모든 아키텍처를 제공하지 않을 수도 있다는 건데요. 지원 여부는 &lt;a href=&quot;https://hub.docker.com&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Docker Hub&lt;/strong&gt;&lt;/a&gt;의 경우 이미지의 태그를 확인해 보면 알 수 있죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-20/2020-02-20-01-02.png&quot; alt=&quot;linuxserver/transmission의 이미지 검색 결과&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.linuxserver.io&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;LinuxServer.io&lt;/strong&gt;&lt;/a&gt;에서 제공하는 &lt;strong&gt;Transmission&lt;/strong&gt; 이미지의 검색 결과입니다. &lt;strong&gt;x86-64&lt;/strong&gt;, &lt;strong&gt;arm&lt;/strong&gt; 그리고 &lt;strong&gt;arm64&lt;/strong&gt; 태그가 보이죠? 이게 바로 지원하는 아키텍처에요.&lt;/p&gt;

&lt;p&gt;도커는 원래 x86 대상의 도구였기 때문에, x86 기반의 데스크탑 서버는 (CPU가 Intel이나 AMD라면) 도커허브에 있는 대부분의 이미지를 사용할 수 있습니다. 그러나 그렇지 않은 경우라면 (라즈베리파이와 같은 대부분의 SBC의 경우) 해당 아키텍처를 지원하는 이미지인지 확인을 해 보셔야 합니다.&lt;/p&gt;

&lt;p&gt;저는 arm 아키텍처인 &lt;strong&gt;오드로이드 XU4&lt;/strong&gt;와 x86-64 아키텍처인 &lt;strong&gt;홈서버 (오드로이드 H2)&lt;/strong&gt; 두 가지로 테스트하고 글을 쓸 거에요. 따라서 두 아키텍처의 설치 코드가 차이가 발생하거나, arm 아키텍처에서 설치할 수 없을 경우에는 이를 따로 알려주고 글을 시작하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;하지만 유명한 서비스들 위주로 소개를 할 것이기 때문에, 대부분은 둘 다 무리 없이 동작할 거에요.&lt;/p&gt;

&lt;h1 id=&quot;docker-compose를-알아만-둡시다&quot;&gt;Docker Compose를 ‘알아만’ 둡시다&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-20/2020-02-20-01-03.png&quot; alt=&quot;Docker Compose 로고&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.docker.com/compose&quot; target=&quot;_blank&quot;&gt;Docker Compose 소개 문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker Compose&lt;/strong&gt;는 여러 개의 컨테이너로 구성된 도커 어플리케이션을 정의할 수 있게 하는 도구입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt;이라고 하는 &lt;strong&gt;YAML&lt;/strong&gt; 서식의 파일에 구성을 기록하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose up&lt;/code&gt;이라는 명령어를 통해 해당 구성으로 도커 컨테이너를 실행할 수 있게 합니다. 이해가 잘 안되죠?&lt;/p&gt;

&lt;p&gt;우리는 이걸 그냥 &lt;strong&gt;도커 설정을 더 정교하게 할 수 있는 도구&lt;/strong&gt;라고만 생각합시다. 앞으로 제공할 코드가 각 서비스에 대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 구성 프리셋이라서, 그냥 그렇다는 걸 알려만 드리는 거에요.&lt;/p&gt;

&lt;p&gt;심지어 우리는 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 파일을 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose up&lt;/code&gt; 같은 명령어를 콘솔에 칠 생각도 없습니다. &lt;strong&gt;Portainer&lt;/strong&gt;를 설치해서 웹으로 관리할 거에요.&lt;/p&gt;

&lt;h1 id=&quot;portainer&quot;&gt;Portainer&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2020-02-20/2020-02-20-01-04.png&quot; alt=&quot;Portainer 로고&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.portainer.io&quot; target=&quot;_blank&quot;&gt;Portainer 공식 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Portainer&lt;/strong&gt;는 도커 관리 웹 패널입니다. 기능이 꽤 강력해서 원격지의 도커를 관리한다거나 할 수도 있긴 한데요, 우리는 그냥 도커가 깔린 서버에 같이 깔아서 &lt;strong&gt;local&lt;/strong&gt;로만 사용할 겁니다.&lt;/p&gt;

&lt;p&gt;포테이너에는 &lt;strong&gt;Stack&lt;/strong&gt;이라고 하는 관리 메뉴가 있는데요. 여러 개의 컨테이너로 구성된 도커 어플리케이션을 코드를 통해 관리하는 방법이에요. 즉, 도커컴포즈를 사용한다는 의미입니다.&lt;/p&gt;

&lt;p&gt;그래서 우리는 도커와 포테이너 설치까지만 명령어로 설치하고, 나머지는 포테이너를 통해서 웹으로 작업할 거에요. 물론, 서비스가 설치될 폴더를 만들어둔다거나 하는 부분은 콘솔이나, 적어도 FTP나 SMB와 같은 방법으로 하셔야 합니다. 하지만 이정도는 별로 어렵지 않죠.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;앞으로-할-내용들&quot;&gt;앞으로 할 내용들&lt;/h1&gt;

&lt;p&gt;첫 시간은 서버에 도커와 포테이너를 설치하고, &lt;strong&gt;Add stack&lt;/strong&gt; 버튼을 눌러보는 단계까지 진행할 거에요.&lt;/p&gt;

&lt;p&gt;그리고 그 이후에는 재미있어 보이는 순서대로 홈서버에서 실행할 만한 서비스를 설치해 볼 겁니다.&lt;/p&gt;</content><author><name>반야자비</name></author><category term="Docker" /><summary type="html">컴퓨터 업계에서 “Cookbook”이란 어떤 것을 쉽게 설정하거나 구현할 수 있게 하는 코드 묶음을 의미합니다. 우리는 이 쿡북을 통해서 도커 서비스를 쉽게 설치해 보려고 해요.</summary></entry><entry><title type="html">Docker 서비스 설치</title><link href="http://0.0.0.0:4000/2019-12-22/Docker-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%84%A4%EC%B9%98" rel="alternate" type="text/html" title="Docker 서비스 설치" /><published>2019-12-22T00:00:00+09:00</published><updated>2019-12-22T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2019-12-22/Docker%20%EC%84%9C%EB%B9%84%EC%8A%A4%20%EC%84%A4%EC%B9%98</id><content type="html" xml:base="http://0.0.0.0:4000/2019-12-22/Docker-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%84%A4%EC%B9%98">&lt;blockquote&gt;
  &lt;p&gt;도커를 사용하게 되면 OMV 플러그인에 한정되지 않는 수많은 서비스를 설치할 수 있습니다. 그리고 요즘은 도커로 배포되는 서비스도 많아졌어요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt;는 컨테이너 기반의 리눅스 가상화 도구입니다… 라고 업계 용어로 표현하면 선뜻 다가가기가 힘들죠. 우리는 그저 나스를 구축하고자 할 뿐이니까, 쉽게 다시 정의해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt;는 서버 환경에 관계 없이 동일한 방법으로 서비스를 설치할 수 있게 하는 플랫폼입니다.&lt;/p&gt;

&lt;p&gt;음, 아직도 어렵지만 우리의 목적에 맞는 표현은 된 것 같아요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;docker&quot;&gt;Docker?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-22/2019-12-22-01-01.png&quot; alt=&quot;Docker 로고&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker 공식 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앞의 정의를 다시 가져옵시다. &lt;strong&gt;Docker&lt;/strong&gt;는 컨테이너 기반의 리눅스 가상화 도구입니다. &lt;strong&gt;VMWare&lt;/strong&gt;나 &lt;strong&gt;VirtualBox&lt;/strong&gt; 같은 가상 머신과는 다른 개념이지만, 가상화라는 점에서는 비슷한 도구라고 볼 수 있겠네요.&lt;/p&gt;

&lt;p&gt;근데 도커와 같은 가상화가 왜 나스와 같은 개인용 홈서버 구축에 획기적인 도구가 되었을까요? 그건 일단 도커만 설치가 잘 되었다면, 컨테이너 (가상화 공간) 내부는 완벽하게 제작자 의도대로 돌아가는 공간이 되어 있기 때문입니다. 따라서 환경별 차이로 발생하는 설치 문제에 일일이 대응할 필요가 없어지므로, 제작자와 사용자 모두에게 편리한 설치 환경을 제공할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;omv4에-docker-설치하기&quot;&gt;OMV4에 Docker 설치하기&lt;/h1&gt;

&lt;p&gt;OMV4는 Docker CE의 플러그인을 제공하고 있어요. &lt;strong&gt;시스템 &amp;gt; OMV-Extras&lt;/strong&gt; 페이지의 저장소 탭에서 이를 활성화 시켜줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-22/2019-12-22-01-02.png&quot; alt=&quot;Docker CE 저장소 활성화&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 이제 &lt;strong&gt;시스템 &amp;gt; 플러그인&lt;/strong&gt; 페이지에 들어가면 아래와 같이 Docker 패키지가 추가되어 있어요. 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-22/2019-12-22-01-03.png&quot; alt=&quot;Docker CE 패키지 설치&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치하고 나면 &lt;strong&gt;서비스 &amp;gt; Docker&lt;/strong&gt; 메뉴가 추가된 것이 보입니다. 메뉴에 접속하기 전에 Docker 시스템에서 사용하는 데이터를 넣어 둘 공간을 만들어야 하는데요, 이를 위해 공유 폴더 하나를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-22/2019-12-22-01-04.png&quot; alt=&quot;Docker 시스템 폴더 생성&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사실, 이 폴더를 만들지 않고 OMV 내부의 운영체제 공간에 이를 생성하게 할 수도 있어요. 그리고 이 폴더는 우리가 직접 들어가 볼 이유도, 권한도 없으므로 그 편도 나쁘지 않습니다. 다만 이 공간의 용량이 설치하는 도커 서비스에 따라 굉장히 유동적일 수 있으므로, 운영체제 공간의 용량이 부족하다고 생각한다면 넉넉한 곳에 공유 폴더를 생성하여 잡아주도록 합시다.&lt;/p&gt;

&lt;p&gt;이제 &lt;strong&gt;서비스 &amp;gt; Docker&lt;/strong&gt; 페이지에서 도커 서비스를 활성화시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-22/2019-12-22-01-05.png&quot; alt=&quot;Docker 서비스 활성화&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쨘! 그럼 이제 아래와 같이 도커가 활성화되어 준비중인 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-22/2019-12-22-01-06.png&quot; alt=&quot;Docker 관리 페이지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 도커를 사용할 준비가 끝났네요. 이제 컨테이너를 설치해 봅시다.&lt;/p&gt;

&lt;h1 id=&quot;docker-컨테이너-설치&quot;&gt;Docker 컨테이너 설치&lt;/h1&gt;

&lt;p&gt;도커를 사용하여 배포되는 많은 서비스는 &lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Docker Hub&lt;/strong&gt;&lt;/a&gt;라는 이미지 공개 저장소에서 공유되고 있어요. 도커로 배포되는 서비스에 특별한 설명이 없을 경우, 당연히 이 곳에서 받을 수 있다고 생각해도 될 정도입니다.&lt;/p&gt;

&lt;p&gt;누구나 도커 이미지를 배포할 수 있는 곳이기 때문에, 잘 관리되어 원활하게 동작하는 이미지를 찾는 것이 쉬운 설치의 지름길입니다.&lt;/p&gt;

&lt;p&gt;잘 만들어진 이미지는 보통,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 개발사 공식 이미지 (Official Image 태그가 붙어 있고, 이미지 이름이 ‘아이디/이미지명’ 구조가 아닌 그냥 ‘이미지명’ 으로 되어 있습니다.)&lt;/li&gt;
  &lt;li&gt;다운로드 횟수가 많은 이미지&lt;/li&gt;
  &lt;li&gt;매뉴얼이 잘 써진 이미지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정도가 되겠습니다. &lt;del&gt;사실 가장 좋은 건 남들이 깔아봤다는 이미지&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;자, 이제 하나 골라서 설치해 봅시다.&lt;/p&gt;

&lt;h2 id=&quot;docker-실행-명령-이해하기&quot;&gt;Docker 실행 명령 이해하기&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/run/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;docker run 공식 문서&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;도커 이미지는 보통 이미지의 실행 명령어와 같이 공유가 됩니다. 이 명령어가 어떤 의미인지를 이해하고, 각자의 상황에 맞게 바꿔주는 것이 가장 중요합니다.&lt;/p&gt;

&lt;p&gt;일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt;으로 시작되는 이 실행 명령어의 각 요소가 어떤 의미인지 알아봅시다. 예시로는 제가 제작한 &lt;del&gt;허접한&lt;/del&gt; 이미지를 가져왔어요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d \
  --name=showdown \
  -e PUID=0 \
  -e PGID=100 \
  -e PERMISSION=777 \
  -p 4080:80 \
  -p 4040:4040 \
  -p 4088:8080 \
  -p 4091:9091 \
  -p 4413:51413 \
  -p 4413:51413/udp \
  -v /path/to/transmission/downloads:/transmission \
  -v /path/to/showdown:/showdown \
  -v /path/to/showdown-manager:/showdown-manager \
  -v /path/to/output/files:/output \
  --restart unless-stopped \
  banyazavi/showdown:amd64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt; (역슬래시, 환경에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;￦&lt;/code&gt; 으로 보일 수도 있습니다.) 는 터미널에서 명령이 끝나지 않았음을 의미합니다. 즉, 저 명령은 ‘'를 제거하고 한 줄로 쓴 것과 동일해요. 근데 그건 너무 길잖아요. 그래서 보통 저렇게 나누어 씁니다.&lt;/p&gt;

&lt;h3 id=&quot;docker-run&quot;&gt;docker run&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt;은 컨테이너 만들어 실행한다는 의미입니다.&lt;/p&gt;

&lt;h3 id=&quot;-d&quot;&gt;-d&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt;는 이 컨테이너를 백그라운드로 실행한다는 의미에요. 이 옵션이 생략된다면 명령 실행 시 로그가 화면에 출력되며, 터미널 종료 시 컨테이너도 종료하게 됩니다.&lt;/p&gt;

&lt;p&gt;여기까지는 OMV 도커 플러그인에서 신경쓸 필요가 없는 부분입니다. 플러그인에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -d&lt;/code&gt;까지를 당연히 사용하는 것으로 간주하거든요. 하지만 이 다음부터는 상황에 따라 바꿔줘야 할 일이 굉장히 많아집니다.&lt;/p&gt;

&lt;h3 id=&quot;namecontainter_name&quot;&gt;–name=CONTAINTER_NAME&lt;/h3&gt;

&lt;p&gt;이 부분은 컨테이너 각각을 인식하는 이름을 지어주는 부분입니다. 같은 이미지에 대한 컨테이너를 여러 개 만들 수도 있으므로, 이를 구분해 주기 위해 사용합니다.&lt;/p&gt;

&lt;p&gt;이 부분을 생략하면 임의의 이름으로 컨테이너가 생성되게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;[NOTE]&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;도커가 임의로 컨테이너 이름을 붙이는 규칙은 &lt;strong&gt;형용사_과학자 이름&lt;/strong&gt; 구조입니다. 컨테이너 이름을 보고 어떤 사람을 의미하는 것인지 추측해보세요. &lt;del&gt;전 mad_einstein 나옴&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;-e-keyvalue&quot;&gt;-e KEY=VALUE&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt;는 환경 변수를 지정하는 옵션입니다. 컨테이너 실행 시 상황에 따라 설정값을 바꿔줘야 하는 경우가 있는데, 그 값을 컨테이너 내부에 전달해 주는 옵션이에요.&lt;/p&gt;

&lt;p&gt;예시처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;-e PUID=0&lt;/code&gt; 이라고 적혀 있다면, PUID라는 내부 옵션을 0으로 설정한다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;이 옵션이 무슨 의미인지, 무슨 값을 사용할 수 있는지는 이미지마다 달라요. 해당 도커 이미지의 매뉴얼을 확인하세요.&lt;/p&gt;

&lt;h3 id=&quot;-p-local_portcontainer_port&quot;&gt;-p LOCAL_PORT:CONTAINER_PORT&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;는 이 컨테이너에서 사용하는 포트를 컨테이너 바깥 (= 우리가 접속할 수 있는 곳) 과 연결해 줄 수 있는 포트 매핑 옵션입니다. 어렵게 생각할 것 없이, 컨테이너를 공유기로 가정하고, 그 안팎으로 포드포워딩을 해준다고 생각하면 됩니다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;-p 4080:80&lt;/code&gt;은 컨테이너 내부에서 사용하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;80&lt;/code&gt;번 포트를 컨테이너 밖에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;4080&lt;/code&gt;번으로 생각하고 접근한다는 의미입니다.&lt;/p&gt;

&lt;p&gt;보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;80&lt;/code&gt;번 포트는 웹 서버가 사용하는 포트이므로, 컨테이너 설치 후 웹 브라우저를 열어 &lt;code class=&quot;highlighter-rouge&quot;&gt;나스_주소:4080&lt;/code&gt;으로 접속하면 서비스에 관련한 뭔가가 뜰 것을 기대할 수 있죠.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt; 왼쪽의 로컬 포트는 나스에서 현재 사용중인 포트와 겹치면 안 되므로, 이미 사용중인 서비스의 포트를 고려하여 겹치지 않는 번호를 할당합니다. 일반적으로 &lt;strong&gt;HTTP&lt;/strong&gt; 공식 포트인 &lt;code class=&quot;highlighter-rouge&quot;&gt;80&lt;/code&gt;, &lt;strong&gt;HTTPS&lt;/strong&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;443&lt;/code&gt;이 잘 겹치고, 이 포트에서 파생된 &lt;code class=&quot;highlighter-rouge&quot;&gt;8080&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;8000&lt;/code&gt; 등도 자주 겹치는 편이에요.&lt;/p&gt;

&lt;h3 id=&quot;-v-localpathcontainerpath&quot;&gt;-v /local/path:/container/path&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;는 볼륨 바인딩이라고 하여, 컨테이너 내부의 특정 경로를 나스의 특정 경로와 이어 주는 역할을 합니다. 일종의 공유 폴더와 같은 셈이죠. 또한 폴더 뿐만 아니라 파일도 연결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이에 따라서 예시의 &lt;code class=&quot;highlighter-rouge&quot;&gt;-v /path/to/transmission/downloads:/transmission&lt;/code&gt; 부분을 해석하면, 컨테이너 내부에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/transmission&lt;/code&gt;이라는 폴더가 있는데, 이를 나스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/path/to/transmission/downloads&lt;/code&gt; 폴더와 연결시킨다는 뜻입니다. 물론 &lt;code class=&quot;highlighter-rouge&quot;&gt;/path/to/transmission/downloads&lt;/code&gt;라는 폴더가 있을 리 없으니, 그 부분을 이 목적에 사용될 폴더의 경로로 바꿔줘야 겠죠.&lt;/p&gt;

&lt;p&gt;주의할 것은, 반드시 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;으로 시작되는 절대 경로로 적어야 한다는 점입니다. 목적 폴더에 접속한 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;pwd&lt;/code&gt; 명령을 실행하여 절대 경로를 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;restart-restart_policy&quot;&gt;–restart restart_policy&lt;/h3&gt;

&lt;p&gt;도커는 가상 머신과는 다르게, 컨테이너에서 실행하는 내용이 끝나면 컨테이너를 멈추게 됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;--restart&lt;/code&gt;는 이 때 컨테이너를 어떻게 재시작할지 정책에 대한 설정입니다. 네 종류가 있어요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;no&lt;/code&gt;: 재시작하지 않습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;always&lt;/code&gt;: 항상 재시작합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unless-stopped&lt;/code&gt;: 종료되지 않는 한 항상 재시작합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;on-failure&lt;/code&gt;: 컨테이너가 오류로 꺼졌을 때만 재시작합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2번과 3번이 차이가 없어 보일 수 있는데, 두 옵션의 차이는 컨테이너가 중단된 후 도커 (또는 나스째로) 가 재부팅 되었을 때 차이가 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;always&lt;/code&gt;는 무조건 다시 켜지지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;unless-stopped&lt;/code&gt;는 도커가 중단된 후 나스가 재부팅 되었을 때는 다시 켜지지 않아요.&lt;/p&gt;

&lt;h3 id=&quot;userimagetag&quot;&gt;user/image[:tag]&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;banyazavi/showdown:amd64&lt;/code&gt;으로 표현되어 있는 마지막 부분은 이 이미지의 정보입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;는 생략 가능한 옵션으로, 생략하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;latest&lt;/code&gt; 태그를 찾아 실행시키게 됩니다. 버전이나 실행 환경의 차이에 따라 이미지를 나누어둔 경우가 있으므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;latest&lt;/code&gt;를 사용해도 되는지, 자신에게 맞는 태그가 있는지 확인할 필요가 있어요.&lt;/p&gt;

&lt;h1 id=&quot;omv4에서-도커-컨테이너-실행하기---nextcloud-설치&quot;&gt;OMV4에서 도커 컨테이너 실행하기 - Nextcloud 설치&lt;/h1&gt;

&lt;p&gt;물론 우리는 저 내용을 터미널에 입력할 필요는 없습니다. &lt;strong&gt;서비스 &amp;gt; Docker&lt;/strong&gt; 페이지에서 같은 작업을 수행할 수 있거든요.&lt;/p&gt;

&lt;h2 id=&quot;실행-명령-확인&quot;&gt;실행 명령 확인&lt;/h2&gt;

&lt;p&gt;그 시범으로 &lt;a href=&quot;https://nextcloud.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Nextcloud&lt;/strong&gt;&lt;/a&gt;라는 설치형 클라우드를 가져왔습니다. 그리고 &lt;a href=&quot;https://hub.docker.com/_/nextcloud/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Docker Hub - Nextcloud&lt;/strong&gt;&lt;/a&gt;의 매뉴얼과 인터넷의 수많은 팁을 통해 아래와 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 명령으로 서비스를 설치할 수 있다고 알게 되었습니다. &lt;del&gt;고 칩시다.&lt;/del&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d \
  --name=omv4_nextcloud
  --restart always \
  -p 6080:80 \
  -v nextcloud:/var/www/html \
  nextcloud
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령어 내용대로 컨테이너를 만들어 볼 겁니다.&lt;/p&gt;

&lt;h2 id=&quot;docker-플러그인에서-설정&quot;&gt;Docker 플러그인에서 설정&lt;/h2&gt;

&lt;p&gt;우선, 뭔가 폴더를 연결시켜줘야 하는 듯 싶으니, 공유 폴더에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;nextcloud&lt;/code&gt;라는 폴더를 하나 만들어 둡니다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;strong&gt;서비스 &amp;gt; Docker&lt;/strong&gt; 페이지에서 &lt;strong&gt;복제본 당겨오기&lt;/strong&gt; 버튼을 눌러 이미지를 가져오구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-22/2019-12-22-01-07.png&quot; alt=&quot;Nextcloud 이미지 가져오기&quot; /&gt;&lt;/p&gt;

&lt;p&gt;꼬리표 부분을 생략하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;latest&lt;/code&gt; 태그의 이미지를 가져오게 됩니다. 혹시 다른 &lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;를 가져오려면 &lt;strong&gt;꼬리표&lt;/strong&gt; 에 태그를 입력해 주세요.&lt;/p&gt;

&lt;p&gt;그리고 사용할 nextcloud 이미지를 클릭하고 &lt;strong&gt;복제본 실행&lt;/strong&gt; 버튼을 눌러 아래 그림과 같이 설정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-22/2019-12-22-01-08.png&quot; alt=&quot;Nextcloud 컨테이너 실행&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 부분이 무엇을 의미하는지는, 윗 챕터를 열심히 읽었으면 쉽게 이해할 수 있을 거에요.&lt;/p&gt;

&lt;p&gt;이 경우에는 환경 변수가 엄청나게 많이 나오는데요, 이것은 이미지에서 기본값으로 설정해둔 모든 환경 변수가 다 표시되는 것으로 직접 설정한 것이 아닙니다. 만약 필요하다면 여기에 환경 변수를 새롭게 추가하거나 기존 변수를 수정할 수도 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너-실행-확인&quot;&gt;컨테이너 실행 확인&lt;/h2&gt;

&lt;p&gt;일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;80&lt;/code&gt; 포트가 서비스 접속 포트이고, 우리는 이것을 &lt;code class=&quot;highlighter-rouge&quot;&gt;6080&lt;/code&gt;으로 설정했으니, &lt;code class=&quot;highlighter-rouge&quot;&gt;http://나스주소:6080&lt;/code&gt;으로 접속해 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-22/2019-12-22-01-09.png&quot; alt=&quot;Nextcloud 최초 접속 화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;잘 뜨네요. 이제 이 페이지에서 남은 설정을 완료하고 서비스를 사용하면 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;[NOTE]&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;지금 글의 방법으로 설치한 넥스트클라우드는 별도의 DB를 설치하지 않아 &lt;strong&gt;SQLite&lt;/strong&gt;로만 설정하여 사용할 수 있습니다. 그림에서 경고하듯 성능이 좋은 편은 아니니 실제로 사용하시려면 DB를 같이 설치하여 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그리고-남은-이야기&quot;&gt;그리고 남은 이야기&lt;/h1&gt;

&lt;p&gt;이것으로 &lt;strong&gt;OMV4 자작 NAS 구축하기&lt;/strong&gt;는 끝입니다. 나머지는 기존의 글을 응용하여 직접 플러그인이나 도커 컨테이너를 설치하여 기능을 확장할 수 있을 거에요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;openmediavault&lt;/strong&gt;는 시놀로지에 비해서는 편의성도, 기능도 완벽하지 못한 나스 솔루션이지만, 커뮤니티에서 개발하여 배포하는 무료 솔루션 중에서는 가장 직관적이고 다루기 쉬운 것이라고 생각합니다. OMV5에서 플러그인 다수를 포기하고 대부분을 외부의 도커 서비스로 대체한 것은 별로 마음에 들지 않긴 하지만… 커뮤니티 개발의 한계라고 납득은 되구요.&lt;/p&gt;

&lt;p&gt;그나마 다행인 점은, 데비안을 기반으로 하여 돌아가기 때문에 데비안/우분투 팁을 참고하여 문제를 해결하기 좋다는 점이 아닐까요.&lt;/p&gt;

&lt;p&gt;이 글들을 통해 성공적인 자작 나스 구축이 되셨으면 좋겠습니다. 감사합니다.&lt;/p&gt;</content><author><name>반야자비</name></author><category term="Let's Encrypt" /><category term="NAS" /><category term="openmediavault" /><category term="SSL" /><category term="TLS" /><summary type="html">도커를 사용하게 되면 OMV 플러그인에 한정되지 않는 수많은 서비스를 설치할 수 있습니다. 그리고 요즘은 도커로 배포되는 서비스도 많아졌어요.</summary></entry><entry><title type="html">Let’s Encrypt SSL/TLS 인증서 적용</title><link href="http://0.0.0.0:4000/2019-12-14/Let's-Encrypt-SSL-TLS-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%A0%81%EC%9A%A9" rel="alternate" type="text/html" title="Let's Encrypt SSL/TLS 인증서 적용" /><published>2019-12-14T00:00:00+09:00</published><updated>2019-12-14T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2019-12-14/Let's%20Encrypt%20SSL%20TLS%20%EC%9D%B8%EC%A6%9D%EC%84%9C%20%EC%A0%81%EC%9A%A9</id><content type="html" xml:base="http://0.0.0.0:4000/2019-12-14/Let's-Encrypt-SSL-TLS-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%A0%81%EC%9A%A9">&lt;blockquote&gt;
  &lt;p&gt;웹 브라우저를 통해 나스에 접속했을 때, ‘주의 요함’ 이라는 메시지가 뜨면 조금 그렇겠죠?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;SSL&lt;/strong&gt;&lt;sup&gt;Secure Socket Layer&lt;/sup&gt;는 네트워크 보안 방식 중에 하나입니다. &lt;strong&gt;TLS&lt;/strong&gt;&lt;sup&gt;Transport Layer Security&lt;/sup&gt;라는 이명으로도 많이 알려져 있는데, 네트워크의 전송(Transport)계층에 보안을 적용시켜 그 상위 계층 프로토콜인 HTTP, FTP의 보안 전송을 가능하게 하죠.&lt;/p&gt;

&lt;p&gt;아무래도 보안을 적용시키는 일이니만큼 약간의 속도 하락을 피할 수는 없으나, 요즘의 웹 브라우저는 보안 인증이 되어 있지 않은 페이지에는 경고를 발생시키는 등, 보안 장치가 되어 있지 않은 사이트의 이용을 엄격하게 제한하는 편이니 적용하는 편이 좋아요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;lets-encrypt&quot;&gt;Let’s Encrypt&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://letsencrypt.org/&quot; target=&quot;_blank&quot;&gt;Let’s Encrypt 공식 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TLS 인증서는 어떤 도메인에 대해 인증기관이 해당 도메인에 대한 인증키를 도메인 운영자에게 제공하고, 도메인에 이를 탑재하여 안전한 사이트임을 인증받게 되는 구조입니다. 즉, 브라우저가 인정하는 인증기관 - 인증기관이 인증하는 도메인과 인증서 - 인증서를 탑재한 도메인의 3박자가 맞아 돌아가며 사이트를 인증하는 방식이에요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Let’s Encrypt&lt;/strong&gt;는 TLS 인증서를 무료로 발급해주는 기관입니다. &lt;strong&gt;DV&lt;/strong&gt;&lt;sup&gt;Domain Validate&lt;/sup&gt; 방식의 인증서를 발급하여 프로그램에 의한 자동화가 가능하기 때문에, 나스에서 이를 쉽게 발급받아 활용할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;사전-작업&quot;&gt;사전 작업&lt;/h1&gt;

&lt;p&gt;홈 네트워크 외부와 뭘 하려면 공유기에 포트포워딩 설정을 해 주어야 한다는 사실은 이제 익숙하죠?&lt;/p&gt;

&lt;h2 id=&quot;공유기-포트포워딩-설정&quot;&gt;공유기 포트포워딩 설정&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-14/2019-12-14-01-01.png&quot; alt=&quot;HTTPS 포트포워딩 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTPS&lt;/strong&gt; 서비스는 기본적으로 &lt;strong&gt;443&lt;/strong&gt; 포트를 사용합니다. 이제 포트를 나스에 중계시키는 포트포워딩 규칙을 설정해 줍시다.&lt;/p&gt;

&lt;h1 id=&quot;lets-encrypt-설치&quot;&gt;Let’s Encrypt 설치&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시스템 &amp;gt; 플러그인&lt;/strong&gt; 메뉴로 들어가 Let’s Encrypt를 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-14/2019-12-14-01-02.png&quot; alt=&quot;Let's Encrypt 설치&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 서비스 메뉴에 &lt;strong&gt;LetsEncrypt&lt;/strong&gt; 메뉴가 보이네요. 기본 설정을 위해 설정 탭으로 들어갑니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-14/2019-12-14-01-03.png&quot; alt=&quot;Let's Encrypt 기본 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후에 발급발을 인증서의 자동 갱신을 위해 &lt;strong&gt;Schedule Refresh&lt;/strong&gt;를 활성화하고, 인증을 위한 메일 주소와 인증서 이름을 설정합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RSA Key Length&lt;/strong&gt;는 더 크게 설정할 수도 있는데, 그만큼 보안 인증에 CPU 자원이 더 소모되니 적당한 수준에서 설정합시다.&lt;/p&gt;

&lt;h1 id=&quot;인증-도메인-추가-및-인증서-생성&quot;&gt;인증 도메인 추가 및 인증서 생성&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Domain&lt;/strong&gt; 탭에서 인증서를 발급받을 도메인을 추가합니다. 저는 저번에 추가한 2개의 서비스에 FTP까지 총 3개를 만들 예정이에요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cpanel.banyazavi.duckdns.org (OMV 제어 패널)&lt;/li&gt;
  &lt;li&gt;ftp.banyazavi.duckdns.org (FTP)&lt;/li&gt;
  &lt;li&gt;torrent.banyazavi.duckdns.org (트랜스미션 RPC)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-14/2019-12-14-01-04.png&quot; alt=&quot;Let's Encrypt 도메인 추가&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인증할 도메인들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;로 이어 붙여줍니다. 한번에 100개 정도까지 가능하다고 합니다. &lt;del&gt;100개까지 쓸 일이…&lt;/del&gt; 이때 도메인 인증을 위한 &lt;strong&gt;Web Root&lt;/strong&gt;는 OMV의 루트 경로인 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/www/openmediavault/&lt;/code&gt;로 지정해주면 됩니다.&lt;/p&gt;

&lt;p&gt;그러면 목록에 인증할 도메인이 목록에 뜨게 되는데, 다음과 같이 &lt;strong&gt;인증서 &amp;gt; Generate&lt;/strong&gt; 버튼을 눌러 인증서를 발급받아 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-14/2019-12-14-01-05.png&quot; alt=&quot;Let's Encrypt 인증서 생성&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인증서가 무사히 생성되었으면 아래와 같은 메시지가 나오며 완료됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-14/2019-12-14-01-06.png&quot; alt=&quot;Let's Encrypt 인증서 완료&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;자-이제-서비스에-적용시켜-보자&quot;&gt;자 이제 서비스에 적용시켜 보자!&lt;/h1&gt;

&lt;h2 id=&quot;ftp에-ssltls-적용&quot;&gt;FTP에 SSL/TLS 적용&lt;/h2&gt;

&lt;p&gt;FTP부터 연결시켜 봅시다. &lt;strong&gt;서비스 &amp;gt; FTP &amp;gt; SSL/TLS&lt;/strong&gt; 탭에 들어가서 아래와 같이 설정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-14/2019-12-14-01-07.png&quot; alt=&quot;FTP SSL/TLS 적용&quot; /&gt;&lt;/p&gt;

&lt;p&gt;고급 설정의 네 가지 항목들은 사용하는 FTP 서비스가 정상적으로 동작하지 않을 때 바꿔 보며 테스트해 보세요. &lt;strong&gt;Required&lt;/strong&gt;를 끄게 되면 평문 FTP로도 통신할 수 있으므로 실제로는 FTP가 적용되지 않은 것일 수도 있다는 점 주의하세요. &lt;strong&gt;묵시적 SSL&lt;/strong&gt;은 FTP 클라이언트에서 &lt;strong&gt;Implicit&lt;/strong&gt;이라고 불리는 보안 모드인데, 간혹 이 모드로 연결이 필요한 경우가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;웹-사이트에-ssltls-적용하기&quot;&gt;웹 사이트에 SSL/TLS 적용하기&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;시스템 &amp;gt; 일반 설정&lt;/strong&gt; 메뉴에 가면 OMV 관리 페이지도 FTP와 비슷하게 인증서를 추가할 수 있습니다. 그런데 우리는 이미 엔진엑스를 통한 역방향 프록시로 관리 페이지에 접속하고 있으므로, 이 곳에서 설정하는 것이 더 편해요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서비스 &amp;gt; Nginx (websites)&lt;/strong&gt; 페이지에 들어가서, 이전에 추가해놨던 서버 설정의 SSL 부분을 아래와 같이 편집합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-14/2019-12-14-01-08.png&quot; alt=&quot;Nginx SSL/TLS 적용&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Only use SSL&lt;/strong&gt; 설정을 켜 주면 HTTPS로만 접속할 수 있습니다. 이 경우에 HTTP로 접속하게 되면 접속을 거부하게 돼요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그리고-남은-이야기&quot;&gt;그리고 남은 이야기&lt;/h1&gt;

&lt;p&gt;이제 OMV4를 이용한 기본적인 나스 구축은 완료되었습니다. 지금까지의 과정을 잘 따라왔다면 다른 서비스들도 플러그인 페이지에서 조회하여 설치하고, 각 서비스 페이지에서 세부 설정하는 방식으로 사용할 수 있어요.&lt;/p&gt;

&lt;p&gt;플러그인이 지원되지 않는 서비스들은 SSH로 직접 접속하여 리눅스에 서비스를 설치하는 방법을 따라하여 설치할 수 있는데요, 이는 서버의 하드웨어 특성을 심하게 타기 때문에 일관적인 가이드가 어렵습니다.&lt;/p&gt;

&lt;p&gt;그래서 요즘은 이런 문제를 피하기 위해 &lt;strong&gt;Docker&lt;/strong&gt;를 이용하여 서비스를 배포하는 경우가 많아졌어요. 그래서 다음 글은 도커를 사용하는 방법에 관한 이야기입니다.&lt;/p&gt;</content><author><name>반야자비</name></author><category term="Let's Encrypt" /><category term="NAS" /><category term="openmediavault" /><category term="SSL" /><category term="TLS" /><summary type="html">웹 브라우저를 통해 나스에 접속했을 때, ‘주의 요함’ 이라는 메시지가 뜨면 조금 그렇겠죠?</summary></entry><entry><title type="html">Nginx 역방향 프록시 설정</title><link href="http://0.0.0.0:4000/2019-12-01/Nginx-%EC%97%AD%EB%B0%A9%ED%96%A5-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%A4%EC%A0%95" rel="alternate" type="text/html" title="Nginx 역방향 프록시 설정" /><published>2019-12-01T00:00:00+09:00</published><updated>2019-12-01T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2019-12-01/Nginx%20%EC%97%AD%EB%B0%A9%ED%96%A5%20%ED%94%84%EB%A1%9D%EC%8B%9C%20%EC%84%A4%EC%A0%95</id><content type="html" xml:base="http://0.0.0.0:4000/2019-12-01/Nginx-%EC%97%AD%EB%B0%A9%ED%96%A5-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%A4%EC%A0%95">&lt;blockquote&gt;
  &lt;p&gt;웹 브라우저를 통해 나스에 접속하는 서비스가 두 개 이상이라면 슬슬 설정할 때가 되었다는 뜻입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;지난 번에 트랜스미션을 설치하며, 웹 브라우저로 접속하는 서비스가 2개가 되었습니다. (OMV 웹 설정 패널, 트랜스미션 RPC)&lt;/p&gt;

&lt;p&gt;이 서비스들을 사용하기 위해서 포트번호를 외우고 다니는 것도 나쁘진 않지만, 뭔가 전문적인 느낌을 위해 &lt;strong&gt;Nginx&lt;/strong&gt;의 &lt;strong&gt;역방향 프록시&lt;/strong&gt;를 사용하여 서브도메인으로 서비스를 관리해 봅시다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;역방향-프록시란&quot;&gt;역방향 프록시란&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;역방향 프록시&lt;/strong&gt;란 &lt;strong&gt;HTTP&lt;/strong&gt; 서비스에서 실제 서버 자원의 통신을 대리하는 서버입니다. 왜 &lt;strong&gt;역방향&lt;/strong&gt;&lt;sup&gt;Reverse&lt;/sup&gt;이라는 이름이 붙었나면, 원래 &lt;strong&gt;프록시 서버&lt;/strong&gt;&lt;sup&gt;Proxy Server&lt;/sup&gt;는 클라이언트의 네트워크에 붙어 클라이언트를 대리하는 서버를 말하거든요. 그런데 얘는 서버를 대리하여 반대 방향으로 프록시 역할을 수행하니, 역방향 프록시인 겁니다.&lt;/p&gt;

&lt;p&gt;물론 고작 나스를 운영하는 입장에서는 그런 원론적인 개념을 이해할 필요는 없고, 우리는 이 기능을 사용하여&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서브도메인을 사용하여 서비스에 접속하고,&lt;/li&gt;
  &lt;li&gt;HTTPS 적용을 쉽게 할 수 있습니다. (이건 다음 글에서 다룰 거에요.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정도가 가능해진다고만 알면 될 것 같네요.&lt;/p&gt;

&lt;h1 id=&quot;사전-작업&quot;&gt;사전 작업&lt;/h1&gt;

&lt;p&gt;앞의 글들을 읽었다면 이해하기 어렵지는 않습니다. 또는 이미 설정되어 있을 수도 있어요.&lt;/p&gt;

&lt;h2 id=&quot;dns-서비스-설정&quot;&gt;DNS 서비스 설정&lt;/h2&gt;

&lt;p&gt;일단, &lt;strong&gt;서브도메인&lt;/strong&gt;이 지원되는 도메인이 필요합니다. 도메인을 구입하였다면 모든 서브도메인을 나스로 연결되도록 네임 서버를 설정해주고, 아니면 DDNS를 사용합니다. 테스트해 보니, &lt;strong&gt;iptime.org&lt;/strong&gt;은 안 되고 &lt;strong&gt;duckdns.org&lt;/strong&gt;가 서브도메인을 지원하네요.&lt;/p&gt;

&lt;h2 id=&quot;공유기-포트포워딩-설정&quot;&gt;공유기 포트포워딩 설정&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-01/2019-12-01-01-01.png&quot; alt=&quot;HTTP 포트포워딩 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지금까지 홈네트워크 바깥에서는 &lt;strong&gt;FTP&lt;/strong&gt;만 사용하게 했었는데, 역방향 프록시를 위해서는 HTTP도 외부에 공개되어야 합니다. &lt;strong&gt;80&lt;/strong&gt; 포트를 통한 접속이 나스에 중계되도록 공유기에 설정합시다.&lt;/p&gt;

&lt;h1 id=&quot;omv-패널-접속-포트-변경&quot;&gt;OMV 패널 접속 포트 변경&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;가 나스의 기본 HTTP 포트인 &lt;strong&gt;80&lt;/strong&gt; 포트를 사용할 건데요, 그럼 OMV 패널과 포트가 겹쳐요. 그래서 &lt;strong&gt;시스템 &amp;gt; 일반 설정&lt;/strong&gt;에서 포트를 적당한 것으로 바꿔줘야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-01/2019-12-01-01-02.png&quot; alt=&quot;OMV 패널 접속 포트 변경&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 포트 번호를 &lt;strong&gt;8080&lt;/strong&gt;으로 바꿨어요.&lt;/p&gt;

&lt;h1 id=&quot;nginx-설치&quot;&gt;Nginx 설치&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;는 유명한 웹 서버 패키지로 &lt;strong&gt;워드프레스&lt;/strong&gt; 등 다른 웹서비스를 위해 사용됩니다. 그렇지만 우리는 이걸 단순히 역방향 프록시용으로만 활용할 거에요. 물론, 나중에 서버를 추가하여 웹서비스용으로도 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;시스템 &amp;gt; 플러그인&lt;/strong&gt; 메뉴로 들어가 엔진엑스를 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-01/2019-12-01-01-03.png&quot; alt=&quot;Nginx 설치&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치가 완료되면 서비스 메뉴에 &lt;strong&gt;Nginx (websites)&lt;/strong&gt; 메뉴가 생성되어 있습니다. 활성화 시켜줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-01/2019-12-01-01-04.png&quot; alt=&quot;Nginx 활성화&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 때, &lt;strong&gt;서버 이름 해시 버킷 크기&lt;/strong&gt;를 최대치로 올려 주는 것이 좋다고 합니다. 이 크기가 작으면 URL이 길어질 경우 오류가 날 수 있대요. 오류를 경험해 본 적은 없지만, 우리의 나스가 이걸 작게 유지해야 할 정도로 성능이 낮은 것은 아니니 높게 잡아줍시다.&lt;/p&gt;

&lt;h1 id=&quot;nginx-서버-추가하기&quot;&gt;Nginx 서버 추가하기&lt;/h1&gt;

&lt;p&gt;이제 &lt;strong&gt;서버&lt;/strong&gt; 탭에 들어가서 서비스를 추가합니다. 2개의 프록시 서버를 추가할 건데요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cpanel.banyazavi.duckdns.org (OMV 제어 패널)&lt;/li&gt;
  &lt;li&gt;torrent.banyazavi.duckdns.org (트랜스미션 RPC)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-12-01/2019-12-01-01-05.png&quot; alt=&quot;Nginx 프록시 서버 추가&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막의 &lt;strong&gt;추가 옵션&lt;/strong&gt;이 매우 중요합니다. 사실 이 내용이 이번 글의 핵심인데요. &lt;strong&gt;8080&lt;/strong&gt; 포트로 설정한 OMV 제어 패널로 예를 들면,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location / {
  proxy_pass http://localhost:8080;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 구문의 의미는 &lt;strong&gt;서버 이름&lt;/strong&gt;으로 접속하여 하위 주소가 &lt;strong&gt;/&lt;/strong&gt;일 경우, Nginx의 입장에서 &lt;strong&gt;http://localhost:8080&lt;/strong&gt;으로 접속한 내용을 서비스한다는 의미입니다.&lt;/p&gt;

&lt;p&gt;나중에 다른 서비스를 설치하였다면, 8080대신 해당 서비스의 포트 번호를 입력하면 됩니다. 나스 내부에 설치된 서비스가 아니라면 localhost 부분도 다른 IP나 주소로 바꾸어 주세요.&lt;/p&gt;

&lt;p&gt;설정이 완료되었다면 등록한 주소로 접속하여 서비스가 제대로 뜨는지 확인해 봅시다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그리고-남은-이야기&quot;&gt;그리고 남은 이야기&lt;/h1&gt;

&lt;p&gt;서브도메인을 지원하지 않는 &lt;strong&gt;iptime.org&lt;/strong&gt;와 같은 DDNS의 경우, 하위 경로를 구분하여 서비스를 쪼개 주는 방법이 가능은 한데요, 추가 옵션이 매우 복잡해집니다. 예전에 간신히 적용에 성공해 본 적이 있긴 한데, 마냥 원활하게 굴러간 것도 아니었으므로 알려 드리긴 어렵고, &lt;del&gt;사실 까먹음&lt;/del&gt; 왠만하면 서브도메인을 통해 사용하는 것이 편해요.&lt;/p&gt;

&lt;p&gt;그리고 Nginx도 OMV5에서 플러그인이 삭제됐습니다. 대신 도커에 역방향 프록시를 지원하는 좋은 이미지들이 많으므로 이 쪽을 쓰는 것이 좋겠네요.&lt;/p&gt;</content><author><name>반야자비</name></author><category term="NAS" /><category term="Nginx" /><category term="openmediavault" /><category term="Reverse Proxy" /><summary type="html">웹 브라우저를 통해 나스에 접속하는 서비스가 두 개 이상이라면 슬슬 설정할 때가 되었다는 뜻입니다.</summary></entry><entry><title type="html">Transmission BitTorrent 클라이언트 설치</title><link href="http://0.0.0.0:4000/2019-11-24/Transmission-BitTorrent-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%84%A4%EC%B9%98" rel="alternate" type="text/html" title="Transmission BitTorrent 클라이언트 설치" /><published>2019-11-24T00:00:00+09:00</published><updated>2019-11-24T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2019-11-24/Transmission%20BitTorrent%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%20%EC%84%A4%EC%B9%98</id><content type="html" xml:base="http://0.0.0.0:4000/2019-11-24/Transmission-BitTorrent-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%84%A4%EC%B9%98">&lt;blockquote&gt;
  &lt;p&gt;공유자가 얼마 없는 토렌트도 세월아 네월아 기다리다 보면 다 받을 수 있는 법입니다. 물론 컴퓨터가 세월아 네월아 켜져 있어야 하죠. 그런데 우리는 나스가 있잖아요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;BitTorrent&lt;/strong&gt;는 파일의 공유를 위한 P2P 프로토콜입니다. 파일을 다운받는 사용자를 동시에 다운받은 부분에 대한 업로더로 활용, 해당 파일에 대한 업로드 자원을 확장시켜 다운로드 속도를 확보하며 빠르게 파일을 확산시키는 방식이죠.&lt;/p&gt;

&lt;p&gt;비트토렌트는 고성능의 배포 서버를 확보하기 어려운 프로그램의 배포에 활용되는 경우가 종종 있습니다. 게임 클라이언트라거나, 오픈소스나 개인 제작자의 파일 배포 등에요. 네, 사실 가장 많이 쓰이는 분야는 방송 등 미디어 컨텐츠에 대한 공유일 거에요. &lt;del&gt;그걸 어떻게 하는지는 알아서 찾아봅시다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;그래서 이 글에서는 &lt;strong&gt;Transmission&lt;/strong&gt;이라고 하는 비트토렌트 클라이언트를 설치하여 토렌트를 통해 파일을 다운받거나 공유하는 방법을 안내합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;transmission-설치&quot;&gt;Transmission 설치&lt;/h1&gt;

&lt;p&gt;일단 트랜스미션을 다운받습니다. OMV4까지는 이를 플러그인으로 지원하기 때문에 매우 쉽게 설치할 수 있어요.&lt;/p&gt;

&lt;p&gt;아래 그림과 같이 &lt;strong&gt;시스템 &amp;gt; 플러그인&lt;/strong&gt; 에서 transmission 패키지를 찾아 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-01.png&quot; alt=&quot;Transmission 설치&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;토렌트-관리-폴더-설정&quot;&gt;토렌트 관리 폴더 설정&lt;/h1&gt;

&lt;p&gt;토렌트를 받기 위해서는 아래와 같이 세 개의 폴더를 만들어야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;complete (완료된 토렌트 파일을 보관할 폴더)&lt;/li&gt;
  &lt;li&gt;incomplete (다운로드 중인 토렌트 파일이 저장될 폴더)&lt;/li&gt;
  &lt;li&gt;watch (다운로드할 토렌트 시드를 저장할 폴더)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 중 &lt;strong&gt;incomplete&lt;/strong&gt;, &lt;strong&gt;watch&lt;/strong&gt; 폴더는 만들지 않아도 됩니다. incomplete 폴더를 만들지 않으면 complete 폴더에 같이 저장되게 되고, watch 폴더가 없으면 시드 파일을 복사하여 토렌트를 받는 방식을 사용할 수 없어요.&lt;/p&gt;

&lt;p&gt;저는 토렌트 전용 공유폴더를 생성하여 설치를 진행하기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-02.png&quot; alt=&quot;torrent 공유 폴더 생성&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 공유 폴더를 생성하고, FTP나 SMB, SSH 등으로 이 아래에 위에서 말한 3개의 폴더를 생성합니다.&lt;/p&gt;

&lt;p&gt;그리고 트랜스미션 프로그램이 이 폴더에 접근할 수 있도록 권한을 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-03.png&quot; alt=&quot;debian-transmission 권한 부여&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;bittorrent-설정&quot;&gt;BitTorrent 설정&lt;/h1&gt;

&lt;p&gt;플러그인을 설치하고 나면 &lt;strong&gt;서비스 &amp;gt; BitTorrent&lt;/strong&gt;라는 메뉴가 생긴 것이 보일 거에요. 해당 메뉴에 들어간 뒤, &lt;strong&gt;Files and Locations&lt;/strong&gt; 탭부터 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-04.png&quot; alt=&quot;Files and Locations 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아까 만든 폴더들을 위 그림과 같이 연결합니다. 그리고 &lt;strong&gt;RPC&lt;/strong&gt; 탭으로 갑니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-05.png&quot; alt=&quot;RPC 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;트랜스미션 RPC&lt;/strong&gt;는 트랜스미션을 관리하는 웹 패널이에요. RPC를 활성화시킨 후 나스의 해당 포트로 접속하게 되면 &lt;strong&gt;µTorrent&lt;/strong&gt;처럼 토렌트를 관리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 이 설정은 &lt;a href=&quot;https://play.google.com/store/apps/details?id=net.yupol.transmissionremote.app&amp;amp;hl=ko&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Transmission Remote&lt;/strong&gt;&lt;/a&gt;과 같은 외부 관리 툴에서도 필요해요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-06.png&quot; alt=&quot;Transmission 활성화&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 트랜스미션을 활성화해주면 끝입니다.&lt;/p&gt;

&lt;h1 id=&quot;transmission을-통해-토렌트-다운받기&quot;&gt;Transmission을 통해 토렌트 다운받기&lt;/h1&gt;

&lt;p&gt;자, 이제 토렌트를 받아봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-07.png&quot; alt=&quot;Transmission RPC 접속&quot; /&gt;&lt;/p&gt;

&lt;p&gt;웹 브라우저에 &lt;strong&gt;NAS주소:포트번호&lt;/strong&gt;로 접속하여 트랜스미션 RPC에 접속하면 위와 같은 화면을 볼 수 있습니다. &lt;strong&gt;열기&lt;/strong&gt; 아이콘을 눌러 토렌트 받기를 시작할 수 있어요.&lt;/p&gt;

&lt;h2 id=&quot;첫-번째-방법-rpc에-시드-파일을-추가하기&quot;&gt;첫 번째 방법, RPC에 시드 파일을 추가하기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-08.png&quot; alt=&quot;RPC에 .torrent 시드 추가&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인터넷에서 받은 &lt;code class=&quot;highlighter-rouge&quot;&gt;.torrent&lt;/code&gt; 시드 파일을 파일 선택 버튼을 통해 추가할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;두-번째-방법-rpc에-마그넷-주소-붙여넣기&quot;&gt;두 번째 방법, RPC에 마그넷 주소 붙여넣기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-09.png&quot; alt=&quot;RPC에 magnet 링크 추가&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아니면 &lt;code class=&quot;highlighter-rouge&quot;&gt;magnet:&lt;/code&gt; 으로 시작하는 링크를 붙여넣어 토렌트를 다운받을 수도 있구요.&lt;/p&gt;

&lt;h2 id=&quot;세-번째-방법-watch-폴더에-시드-파일을-복사하기&quot;&gt;세 번째 방법, Watch 폴더에 시드 파일을 복사하기&lt;/h2&gt;

&lt;p&gt;아까 만들어 둔 &lt;strong&gt;watch&lt;/strong&gt; 폴더에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.torrent&lt;/code&gt; 파일을 복사하여 다운로드를 진행할 수도 있어요. 파일을 복사한 뒤 트랜스미션이 시드를 확인하면, 토렌트를 추가하고 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;.added&lt;/code&gt; 확장자로 바꿔놓습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-10.png&quot; alt=&quot;Watch 폴더에 시드 복사&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FTP&lt;/strong&gt;를 통해 시드를 복사해 놓은 장면입니다. 복사 직후 토렌트가 파일을 인식하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;.added&lt;/code&gt; 파일로 바꿔놓았네요.&lt;/p&gt;

&lt;p&gt;아무튼 이렇게 파일을 추가하고 나면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-11.png&quot; alt=&quot;RPC 토렌트 추가 후 화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 토렌트가 추가되어 다운로드 중인 것을 확인할 수 있습니다. 다운로드 중에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;incomplete&lt;/code&gt; 폴더에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.part&lt;/code&gt; 확장자로 파일이 받아지다가,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-24/2019-11-24-01-12.png&quot; alt=&quot;다운받은 파일 확인&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다운이 완료되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;complete&lt;/code&gt; 폴더에 이렇게 받아져 있는 것을 볼 수 있어요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그리고-남은-이야기&quot;&gt;그리고 남은 이야기&lt;/h1&gt;

&lt;p&gt;이 시리즈의 시작 부분에서 언급한 내용이지만, OMV5에서는 플러그인이 삭제되어 트랜스미션을 위와 같이 설정할 수 없습니다.&lt;/p&gt;

&lt;p&gt;OMV가 커뮤니티에서 개발하는 솔루션이므로 도커와 같은 외부의 구축 방식을 사용하는 것이 플러그인 개발 부담이 적긴 하겠지만, 트랜스미션 정도는 핵심 기능으로 고려하고 플러그인을 개발하는 것이 좋았지 싶습니다. 아쉽네요.&lt;/p&gt;</content><author><name>반야자비</name></author><category term="BitTorrent" /><category term="NAS" /><category term="openmediavault" /><category term="Transmission" /><summary type="html">공유자가 얼마 없는 토렌트도 세월아 네월아 기다리다 보면 다 받을 수 있는 법입니다. 물론 컴퓨터가 세월아 네월아 켜져 있어야 하죠. 그런데 우리는 나스가 있잖아요?</summary></entry><entry><title type="html">DuckDNS DDNS 설치</title><link href="http://0.0.0.0:4000/2019-11-10/DuckDNS-DDNS-%EC%84%A4%EC%B9%98" rel="alternate" type="text/html" title="DuckDNS DDNS 설치" /><published>2019-11-10T00:00:00+09:00</published><updated>2019-11-10T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2019-11-10/DuckDNS%20DDNS%20%EC%84%A4%EC%B9%98</id><content type="html" xml:base="http://0.0.0.0:4000/2019-11-10/DuckDNS-DDNS-%EC%84%A4%EC%B9%98">&lt;blockquote&gt;
  &lt;p&gt;언제까지 IP를 입력해서 서비스를 사용할 수는 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;DDNS&lt;/strong&gt;&lt;sup&gt;Dynamic DNS&lt;/sup&gt;란 유동 IP에 대해 &lt;strong&gt;DNS&lt;/strong&gt;&lt;sup&gt;Domain Name System&lt;/sup&gt;를 제공하는 방법입니다. DDNS 서버에 주기적으로 IP 갱신 요청을 보내, 설령 해당 도메인의 IP가 변경되었더라도 빠르게 이를 반영하는 방식으로 동작합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;사실-이건-omv에서-제공하지-않는다&quot;&gt;사실 이건 OMV에서 제공하지 않는다&lt;/h1&gt;

&lt;p&gt;사실 이 글을 주제에 넣는게 맞는지 고민을 했습니다. 왜냐하면 이건 OMV에서 지원하는 서비스가 아니거든요. 하지만 외부 접속이 필요한 시점에서 도메인은 꼭 필요한 것이 되므로, 나스의 설치를 위해서라면 꼭 필요한 과정이라고 생각해서 넣었습니다.&lt;/p&gt;

&lt;p&gt;그리고 굳이 이 글의 방법으로 DDNS를 설치할 필요도 없는데요.&lt;/p&gt;

&lt;h1 id=&quot;공유기에서-ddns-서비스를-지원한다&quot;&gt;공유기에서 DDNS 서비스를 지원한다&lt;/h1&gt;

&lt;p&gt;사실 DDNS는 홈 네트워크를 외부에서 쉽게 접속하기 위한 방법이고, 이 방법을 위해서는 24시간 동작하는 컴퓨팅 장비가 필요하기 때문에, 이 조건을 충족하는 장비인 공유기에서도 DDNS를 지원합니다.&lt;/p&gt;

&lt;p&gt;ipTIME의 경우 &lt;strong&gt;iptime.org&lt;/strong&gt;와 &lt;strong&gt;ipdisk.co.kr&lt;/strong&gt;를 제공하고 있고, ASUS의 경우 &lt;strong&gt;asuscomm.com&lt;/strong&gt; 이름으로 제공하며, 그 외 다른 유명 DDNS 연결도 지원하고 있어요.&lt;/p&gt;

&lt;p&gt;하지만 우리 역시 24시간 돌아가는 나스가 있으니! &lt;del&gt;공유기별 방법 다 안내하기도 귀찮고&lt;/del&gt; 나스를 통하여 설치하는 방법을 소개하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;duck-dns&quot;&gt;Duck DNS&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-10/2019-11-10-01-01.png&quot; alt=&quot;Duck DNS 소개&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.duckdns.org/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Duck DNS&lt;/strong&gt;&lt;/a&gt;는 무료 DDNS 서비스 중 하나입니다.&lt;/p&gt;

&lt;p&gt;다른 DDNS 서비스도 있지만, Duck DNS도 꽤 안정적인 서비스이고 서브도메인에 대한 연결도 지원하고 있으므로 나스용으로는 꽤 괜찮은 것 같아요. 그리고 DDNS 갱신도 쉬운 편이에요.&lt;/p&gt;

&lt;p&gt;우선, 가입 후 도메인 등록부터 해 봅시다.&lt;/p&gt;

&lt;h1 id=&quot;duck-dns에-도메인-등록&quot;&gt;Duck DNS에 도메인 등록&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-10/2019-11-10-01-02.png&quot; alt=&quot;Duck DNS 등록 화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;소셜로그인으로 로그인하고 나면 위와 같은 화면이 뜹니다. &lt;strong&gt;토큰은 개인정보로 DDNS 갱신에 필요하니 외부에 노출시키는 일이 없도록 주의합니다.&lt;/strong&gt; &lt;del&gt;누가 대신 갱신해 버릴수도&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;그리고 하고 싶은 도메인을 적은 뒤 &lt;strong&gt;add domain&lt;/strong&gt; 버튼을 누르면, 중복 검사가 완료된 후에,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-10/2019-11-10-01-03.png&quot; alt=&quot;Duck DNS 등록 완료&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 도메인이 등록됩니다!&lt;/p&gt;

&lt;p&gt;이 작업을 하는 컴퓨터와 나스가 같은 공유기 아래 있다면, &lt;strong&gt;update ip&lt;/strong&gt; 버튼을 눌러 DDNS와 IP를 연동시킬 수 있어요. 그러므로 앞으로 5분마다 이 사이트에 접속하여 저 버튼을 눌러주면 됩니다 :) &lt;del&gt;다음 글은 5분마다 갱신 버튼을 누를 불침번을 정하는 방법입니다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;5분 마다 이걸 눌러줄 수는 없으니, 나스가 자동으로 갱신하게 해야겠죠.&lt;/p&gt;

&lt;h1 id=&quot;nas에-자동-갱신-설정하기&quot;&gt;NAS에 자동 갱신 설정하기&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-10/2019-11-10-01-04.png&quot; alt=&quot;Duck DNS Install&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사실 Duck DNS에서 시스템별 자동 갱신 방법을 제공하고 있어요. &lt;a href=&quot;https://www.duckdns.org/install.jsp&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Duck DNS Install&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 방법 그대로 따라해봅시다. 우선 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt;에 접속해서,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo mkdir -p /root/duckdns
$ sudo vi /root/duckdns/duck.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;root의 홈 디렉토리 아래에 &lt;strong&gt;duckdns&lt;/strong&gt; 폴더를 만들고, 그 아래 &lt;strong&gt;duck.sh&lt;/strong&gt; 파일을 만들어 편집합니다. 그리고 파일에 다음과 같이 내용을 넣으세요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo url=&quot;https://www.duckdns.org/update?domains={사용 도메인}&amp;amp;token={할당받은 토큰}&amp;amp;ip=&quot; | curl -k -o ~/duckdns/duck.log -K -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 root 유저가 실행할 수 있도록 권한을 조정합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo chmod 700 /root/duckdns/duck.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 &lt;strong&gt;시스템 &amp;gt; 예약된 작업&lt;/strong&gt;에서 이 스크립트를 추가합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-10/2019-11-10-01-05.png&quot; alt=&quot;Duck DNS 갱신 스크립트 예약&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스크립트가 한번 실행되고 나면 등록된 DDNS 주소로 나스에 접속할 수 있습니다.&lt;/p&gt;

&lt;p&gt;혹시 공유기의 설정 페이지가 뜬다면 공유기의 포트포워딩 설정을 수정하고, 아예 연결이 되지 않는다면 Duck DNS 사이트에 접속하여 공인 IP가 정확하게 등록되었는지 확인해 봅시다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그리고-사실-남은-이야기&quot;&gt;그리고 사실 남은 이야기&lt;/h1&gt;

&lt;p&gt;원래 갱신 스크립트를 생성하고 이를 예약 실행하는 복잡한 방법만 알고 있었는데, 이번에 글을 쓰기 위해 알아보다가 그만…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;freenas용 인스톨 방법을 활용한 간단 설정법을 알게 되었어요.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;방법은 매우 간단하합니다. 다음의 스크립트를 예약된 작업의 명령에 추가시켜주면 된다. 프리나스와는 &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; 명령의 위치가 다르므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/bin/curl&lt;/code&gt;만 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin/curl&lt;/code&gt;로 바꾸어 줍니다. 혹시 &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;이 설치되지 않은 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo apt-get install curl&lt;/code&gt; 명령을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;을 설치해 주세요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/curl http://www.duckdns.org/update/{사용 도메인}/{할당받은 토큰}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 아래와 같이 설정해 주면…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-11-10/2019-11-10-01-06.png&quot; alt=&quot;간단한 Duck DNS 갱신 스크립트 예약&quot; /&gt;&lt;/p&gt;

&lt;p&gt;되네요. &lt;del&gt;앞에 쓴 글 다 날아가는 소리&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;저도 지금은 이 방법으로 쓰고 있습니다.&lt;/p&gt;</content><author><name>반야자비</name></author><category term="DDNS" /><category term="NAS" /><category term="openmediavault" /><summary type="html">언제까지 IP를 입력해서 서비스를 사용할 수는 없습니다.</summary></entry><entry><title type="html">FTP 설정</title><link href="http://0.0.0.0:4000/2019-10-27/FTP-%EC%84%A4%EC%A0%95" rel="alternate" type="text/html" title="FTP 설정" /><published>2019-10-27T00:00:00+09:00</published><updated>2019-10-27T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2019-10-27/FTP%20%EC%84%A4%EC%A0%95</id><content type="html" xml:base="http://0.0.0.0:4000/2019-10-27/FTP-%EC%84%A4%EC%A0%95">&lt;blockquote&gt;
  &lt;p&gt;FTP만 잘 설정되어 있어도 나스를 통한 파일 전송은 대부분 해결됩니다. 괜히 이름이 &lt;strong&gt;File Transfer Protocol&lt;/strong&gt;이 아니거든요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;FTP&lt;/strong&gt;&lt;sup&gt;File Transfer Protocol&lt;/sup&gt;는 네트워크에서 가장 유명한 파일 전송 방법입니다. &lt;del&gt;이름이 &lt;strong&gt;파일 전송 프로토콜&lt;/strong&gt;이니까&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;유명한 프로토콜이라 거의 대부분의 환경에서 이를 지원하므로, 나스라면 반드시 깔아야 할 서비스라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 글을 통해 서버를 설정한 후,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://filezilla-project.org/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;FileZilla&lt;/strong&gt;&lt;/a&gt;를 통해 단순히 나스의 파일을 관리할 수도 있구요,&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.raidrive.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;RaiDrive&lt;/strong&gt;&lt;/a&gt;를 설치해 집 밖에서도 아예 네트워크 드라이브처럼 쓴다거나,&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.cxinventor.file.explorer&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;CX 파일 탐색기&lt;/strong&gt;&lt;/a&gt;와 같은 안드로이드 탐색기 앱에 연결시켜 쓸 수도 있고,&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=dk.tacit.android.foldersync.lite&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;FolderSync&lt;/strong&gt;&lt;/a&gt;를 설치하여 스마트폰과 나스의 데이터를 동기화 시킬 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결론은, 대부분의 파일 관리 서비스는 FTP를 지원하므로, 그 활용 가치가 높습니다. 빨리 깔아봅시다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;ftp-활성화하기&quot;&gt;FTP 활성화하기&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-01.png&quot; alt=&quot;FTP 서비스 활성화&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서비스 &amp;gt; FTP&lt;/strong&gt; 페이지에서 서비스를 활성화합니다. 여러 일반 설정이 있는데,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;포트&lt;/strong&gt;: FTP를 서비스할 포트를 지정합니다. 기본값은 &lt;strong&gt;21&lt;/strong&gt;인데, 이 포트번호는 매우&lt;sup&gt;x100&lt;/sup&gt; 유명한 번호 중 하나이므로, 적절한 보안 대책이 없다면 다른 번호로 바꿔줘도 좋습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최대 클라이언트&lt;/strong&gt;: 나스에 동시 접속할 FTP 클라이언트의 최대 숫자입니다. 나스 성능과 나누어 준 사용자 아이디를 고려하여 적당히 설정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;호스트당 최대 연결&lt;/strong&gt;: 1개 접속자에서 얼마나 많은 연결을 가져갈 수 있는지에 대한 설정입니다. “어차피 1개 아니야?” 싶지만, FTP를 통해 영화+자막을 스트리밍한다거나, 이전 연결이 비정상적 종료되어 서버가 아직 끊어진 줄 모른다든지 하는 이유로 더 많이 필요할 수도 있어요. 적당한 크기로 잡아둔 뒤, 나스 사용 패턴을 확인하여 FTP 연결이 거부되거나 끊긴다 싶을 때 이 값을 조금씩 올려주면 됩니다. 아니면 처음부터 넉넉하게 설정하거나요.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최대 로그인 시도 횟수&lt;/strong&gt;: 설명 그대로인데, 1로 둡니다. &lt;del&gt;딱히 변경해야 하는 이유를 모르겠어요…&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;익명 FTP 활성화&lt;/strong&gt;: 이 옵션을 켜면 &lt;strong&gt;Anonymous&lt;/strong&gt; 로그인이 가능해지는데 (일반적으로 ID를 메일 주소로 넣는다고 해요.), 우리는 공개된 FTP서버는 아니니 활성화 할 필요는 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;환영 메시지&lt;/strong&gt;: FTP에 접속하게 되면 나오는 메시지! 인데… CLI 환경이 아닌 이상 이를 표시해 주는 클라이언트가 거의 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래 옵션도 읽어봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-02.png&quot; alt=&quot;FTP 고급 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다른 옵션들은 크게 관심이 없고, (대역폭 제한이나 다시 시작, 전송 기록 정도가 쓸 만합니다.) 수동 FTP 설정을 알아볼 필요가 있는데요. 이 옵션을 켜지 않으면 나스가 알아서 포트를 설정하지만, 우리는 공유기 아래에 나스를 두고 서비스할 것이므로 이 범위를 지정해 줄 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;저는 활성화 시 기본으로 잡혀 있는 &lt;strong&gt;49152:65534&lt;/strong&gt; 대역을 사용하기로 했습니다. 만약 해당 범위에 다른 서비스 포트가 포함된다면 다른 범위로 잡아주세요.&lt;/p&gt;

&lt;h1 id=&quot;공유-폴더-추가&quot;&gt;공유 폴더 추가&lt;/h1&gt;

&lt;p&gt;SMB 설정을 했다면 큰 설명이 필요 없는 과정입니다. 그림 두개로 끝낼게요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-03.png&quot; alt=&quot;Content 공유 추가&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 Contents 폴더를 추가하고, 같은 방법으로 Public 폴더도 추가시키면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-04.png&quot; alt=&quot;공유 추가 완료&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 화면이 나오며 완성!&lt;/p&gt;

&lt;h1 id=&quot;filezilla로-확인하기&quot;&gt;FileZilla로 확인하기&lt;/h1&gt;

&lt;p&gt;앞에서 얘기했듯 FTp를 사용하는 프로그램은 정말 많이 있는데, 일단 &lt;a href=&quot;https://filezilla-project.org/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;FileZilla&lt;/strong&gt;&lt;/a&gt;를 사용해 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-05.png&quot; alt=&quot;FileZilla 빠른 연결 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식으로 나스의 IP (또는 도메인), 사용자명과 비밀번호, 포트를 넣고 연결하면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-06.png&quot; alt=&quot;FileZilla 리모트 사이트 화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 공유 폴더가 뜨는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그리고-남은-아니-이게-더-중요한-것-같은데&quot;&gt;그리고 남은… 아니 이게 더 중요한 것 같은데?&lt;/h1&gt;

&lt;p&gt;물론 홈 네트워크 내부에서만 사용하려고 했으면 FTP를 설정할 필요까지는 없습니다. &lt;del&gt;그래서 SMB를 먼저 했죠?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;이 단계에서는 공유기 외부에서도 나스의 FTP에 접속할 수 있도록 포트포워딩 설정을 할 건데요. ipTIME과 ASUS 공유기 2종류에 대해서 설정하는 법을 보여드리는데, 다른 공유기도 비슷한 과정으로 &lt;strong&gt;포트포워딩&lt;/strong&gt; 메뉴에서 쉽게 설정할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;iptime-포트포워딩-설정&quot;&gt;ipTIME 포트포워딩 설정&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;NAT/라우터 관리 &amp;gt; 포트포워드 설정&lt;/strong&gt;에서 할 수 있어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-07.png&quot; alt=&quot;ipTIME FTP Ctrl 포트포워드 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이건 FTP 제어 포트,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-08.png&quot; alt=&quot;ipTIME FTP Data 포트포워드 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이건 FTP 데이터 통신 포트 설정입니다. OMV에서 설정을 바꾸어줬다면 여기에서도 동일하게 적어주어야 해요.&lt;/p&gt;

&lt;h2 id=&quot;asus-포트포워딩-설정&quot;&gt;ASUS 포트포워딩 설정&lt;/h2&gt;

&lt;p&gt;ASUS 공유기는 &lt;strong&gt;WAN &amp;gt; 가상서버 / 포트 포워딩&lt;/strong&gt; 페이지에서 설정할 수 있어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-09.png&quot; alt=&quot;ASUS FTP Ctrl 포트포워드 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로 FTP 제어 포트,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-27/2019-10-27-01-10.png&quot; alt=&quot;ASUS FTP Data 포트포워드 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;FTP 데이터 통신 포트 설정입니다. 내부 포트 번호를 적지 않으면 외부와 같은 포트번호로 자동 포워딩된다는 의미입니다.&lt;/p&gt;

&lt;p&gt;이렇게 설정한 후, 공유기의 외부 IP/도메인과 외부 포트번호를 가지고 연결이 되는지 확인하면 됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그리고-진짜-남은-이야기&quot;&gt;그리고 진짜 남은 이야기&lt;/h1&gt;

&lt;p&gt;지금은 공유기 외부에서 접속할 때 인터넷 사업자가 제공해 준 공유기의 공인 IP를 사용하고 있는데, 일반적인 가정집의 경우 이 번호가 주기적으로 바뀝니다. 언제 바뀔지도 모르는 이 번호를 통해서 외부 접속을 할 수는 없으니, &lt;strong&gt;DDNS&lt;/strong&gt;&lt;sup&gt;Dynamic Domain Name System&lt;/sup&gt; 설정을 해야 해요. 그리고 앞으로 설명할 서비스들이 대부분 외부 접속을 염두에 두고 있구요.&lt;/p&gt;

&lt;p&gt;그래서 다음 글은 공유기에서 DDNS 설정하는 방법이 되겠습니다.&lt;/p&gt;</content><author><name>반야자비</name></author><category term="FTP" /><category term="NAS" /><category term="openmediavault" /><summary type="html">FTP만 잘 설정되어 있어도 나스를 통한 파일 전송은 대부분 해결됩니다. 괜히 이름이 File Transfer Protocol이 아니거든요.</summary></entry><entry><title type="html">SMB 네트워크 드라이브 설정</title><link href="http://0.0.0.0:4000/2019-10-26/SMB-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EC%84%A4%EC%A0%95" rel="alternate" type="text/html" title="SMB 네트워크 드라이브 설정" /><published>2019-10-26T00:00:00+09:00</published><updated>2019-10-26T00:00:00+09:00</updated><id>http://0.0.0.0:4000/2019-10-26/SMB%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C%20%EC%84%A4%EC%A0%95</id><content type="html" xml:base="http://0.0.0.0:4000/2019-10-26/SMB-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EC%84%A4%EC%A0%95">&lt;blockquote&gt;
  &lt;p&gt;윈도우 홈 네트워크 아래서라면 SMB보다 편한 것은 없는 것 같습니다. 네트워크 드라이브가 지원되거든요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;SMB&lt;/strong&gt;&lt;sup&gt;Server Message Block&lt;/sup&gt;은 윈도우에서 파일이나 장치를 공유하기 위한 프로토콜입니다. 윈도우 탐색기의 네트워크에 들어가면 보이는 홈 네트워크상의 장치에 사용되는 프로토콜이라고 생각하면 될 거에요. SMB 프로토콜을 구현한 오픈 소스 소프트웨어 이름이 &lt;strong&gt;Samba&lt;/strong&gt;인데요. 그래서인지 SMB 프로토콜 자체를 &lt;strong&gt;삼바&lt;/strong&gt;라고 부르기도 하는 것 같네요.&lt;/p&gt;

&lt;p&gt;아무튼 우리는 OMV의 SMB 설정을 환성화 한 후, 같은 홈 네트워크에 속한 윈도우의 &lt;strong&gt;네트워크 드라이브 연결&lt;/strong&gt; 기능으로 연결시킬 겁니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;호스트-이름-설정하기&quot;&gt;호스트 이름 설정하기&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시스템 &amp;gt; 네트워크&lt;/strong&gt; 페이지에서 호스트 이름을 설정합니다. 이건 사실 SMB하고는 직접적으로 상관은 없지만, 네트워크 드라이브를 편하게 연결하기 위해 필요해요.&lt;/p&gt;

&lt;p&gt;그리고 기본적으로 여기서 설정한 이름이 네트워크 상에서 이 나스의 이름으로 쓰이므로, 알아보기 쉽게 지정하는 것이 좋겠죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-26/2019-10-26-01-01.png&quot; alt=&quot;호스트 이름 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간단하게 &lt;strong&gt;OMV4&lt;/strong&gt;라고 이름을 지었습니다. &lt;strong&gt;도메인 이름&lt;/strong&gt;도 설정이 가능하긴 한데, 홈 서버 수준에서는 이것까지 설정하여 구분해야 할 이유는 별로 없습니다. &lt;strong&gt;알림&lt;/strong&gt; 서비스를 사용하여 OMV가 메일을 보낼 것이 아니라면 도메인 이름 설정은 생략해도 괜찮습니다.&lt;/p&gt;

&lt;h1 id=&quot;smb-활성화&quot;&gt;SMB 활성화&lt;/h1&gt;

&lt;p&gt;그리고 &lt;strong&gt;서비스 &amp;gt; SMB/CIFS&lt;/strong&gt; 페이지에서 서비스 활성화를 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-26/2019-10-26-01-02.png&quot; alt=&quot;SMB/CIFS 서비스 활성화&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사실 이 아래에 몇 가지 설정이 더 있는데, 기본적인 사용에는 기본값에서 굳이 변경할 필요가 없으므로 스크린샷에 포함하지는 않았어요. 굳이 사용해 볼 만한 옵션이라면…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;홈 경로 활성화&lt;/strong&gt;: &lt;strong&gt;사용자 홈 디렉터리&lt;/strong&gt;를 활성화 시켰다면 이 옵션을 사용하여 사용자별 홈 폴더를 제공해 줄 수 있습니다. 소규모 사업장과 같은 곳에서 나스를 통한 개인별 백업 공간을 제공하려는 경우 유용할 수 있겠네요. 또는 가정에 여러 대의 PC를 여러 구성원이 사용할 때 개인 폴더로 활용하거나…&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;공유-폴더-추가&quot;&gt;공유 폴더 추가&lt;/h1&gt;

&lt;p&gt;이제 &lt;strong&gt;공유&lt;/strong&gt; 탭에 들어가서 아래와 같이 공유 폴더를 추가합니다. 이후에도 OMV에서 설정하는 대부분의 서비스에서 이와 같이 공유 폴더 추가하는 과정이 필요해요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-26/2019-10-26-01-03.png&quot; alt=&quot;Content 공유 추가&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만들어 둔 공유 폴더를 선택할 수 있습니다. 저는 그림과 같이 &lt;strong&gt;Contents&lt;/strong&gt; 폴더를 공유하고, 추가적으로 &lt;strong&gt;Public&lt;/strong&gt; 폴더도 공유하도록 할게요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;home&lt;/strong&gt; 폴더는 이렇게 공유하면 안 됩니다! 앞에서 홈 경로 활성화를 해주었으면 여기서 추가하지 않아도 자연스럽게 사용자별로 제공이 된거든요. 오히려 공유하면, 경우에 따라 &lt;strong&gt;모든 사용자가 다른 사용자 홈 폴더에 접근하게 될 수도 있습니다!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-26/2019-10-26-01-04.png&quot; alt=&quot;공유 추가 완료&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용할 공유 폴더를 모두 추가하고 나면 이렇게 목록을 확인할 수 있어요.&lt;/p&gt;

&lt;h1 id=&quot;네트워크-드라이브-연결하기&quot;&gt;네트워크 드라이브 연결하기&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-26/2019-10-26-01-05.png&quot; alt=&quot;Windows 내 PC 컴퓨터 탭&quot; /&gt;&lt;/p&gt;

&lt;p&gt;윈도우의 &lt;strong&gt;내 PC&lt;/strong&gt;에 들어가면 상단 탭에 위와 같은 메뉴들이 있습니다. &lt;strong&gt;네트워크 드라이브 연결&lt;/strong&gt;을 눌러 설정을 시작합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-26/2019-10-26-01-06.png&quot; alt=&quot;네트워크 드라이브 추가 화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;적당한 드라이브 이름을 할당하고 폴더 경로를 입력합니다. 폴더 경로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;\\호스트 이름\공유 폴더 이름&lt;/code&gt; 과 같이 설정할 수 있어요. 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;\\나스 IP\공유 폴더 이름&lt;/code&gt; 과 같이 설정해도 됩니다. &lt;strong&gt;로그인할 때 다시 연결&lt;/strong&gt; 옵션을 선택하면 재부팅 후 자동으로 연결이 되고, 윈도우와 나스의 계정 정보가 다를 경우 (대부분 다를 겁니다.) &lt;strong&gt;다른 자격 증명을 사용하여 연결&lt;/strong&gt;을 선택하여 계정 정보를 직접 입력하도록 합니다.&lt;/p&gt;

&lt;p&gt;저는 호스트 이름을 &lt;strong&gt;O&lt;/strong&gt;MV4 라고 지었으므로 &lt;strong&gt;O&lt;/strong&gt; 드라이브를 할당하고, Contents 폴더를 연결할 예정이므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;\\OMV4\Contents&lt;/code&gt; 라고 경로를 입력했어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2019-10-26/2019-10-26-01-07.png&quot; alt=&quot;네트워크 자격 증명 입력 화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이렇게 자격 증명을 입력하는 화면이 나오는데, OMV의 사용자 정보를 입력하면 됩니다.&lt;/p&gt;

&lt;p&gt;정상적으로 입력이 완료되면 네트워크 드라이브가 연결된 후, 연결된 공유 폴더가 새 창으로 나오게 됩니다. 그럼 끝!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;[NOTE]&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;가끔 사용자 정보를 정상적으로 입력해도 계정 정보가 일치하지 않는다는 메시지와 함께 연결이 되지 않는 경우가 있습니다. 여기에는 다양한 원인이 있을 수 있으나, 정상적으로 구성하였는데도 그런 상황이 발생한다면, OMV 웹 패널의 &lt;strong&gt;접근 권한 관리 &amp;gt; 사용자&lt;/strong&gt; 페이지에서 해당 사용자의 비밀번호를 다시 설정해 보세요. 그 후에 정상적으로 되는 경우가 종종 있었습니다.&lt;/p&gt;

  &lt;p&gt;아마도 리눅스 사용자 비밀번호가 SMB에 정상적으로 동기화되지 않는 문제인 것 같네요.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>반야자비</name></author><category term="NAS" /><category term="openmediavault" /><category term="SMB" /><summary type="html">윈도우 홈 네트워크 아래서라면 SMB보다 편한 것은 없는 것 같습니다. 네트워크 드라이브가 지원되거든요.</summary></entry></feed>